[
  {
    "objectID": "index.html#core-aims",
    "href": "index.html#core-aims",
    "title": "Course overview",
    "section": "Core aims",
    "text": "Core aims\nTo introduce sufficient understanding and coding experience for analysing data with non-continuous response variables.\n\n\n\n\n\n\nCourse aims\n\n\n\nTo know what to do when presented with an arbitrary data set e.g.\n\nConstruct\n\na logistic model for binary response variables\na logistic model for proportion response variables\na Poisson model for count response variables\na Negative Binomial model for count response variables (to be added later)\n\nPlot the data and the fitted curve in each case for both continuous and categorical predictors\nAssess the significance of fit\nAssess assumption of the model"
  },
  {
    "objectID": "setup.html",
    "href": "setup.html",
    "title": "2  Setup",
    "section": "",
    "text": "R and RStudio\n\n\nWindows\nDownload and install all these using default options:\n\nR \nRStudio\n\n\n\nMac OS\nDownload and install all these using default options:\n\nR\nRStudio\n\n\n\nLinux\n\nGo to the R installation folder and look at the instructions for your distribution.\nDownload the RStudio installer for your distribution and install it using your package manager."
  },
  {
    "objectID": "materials.html#data",
    "href": "materials.html#data",
    "title": "3  Data",
    "section": "3.1 Data",
    "text": "3.1 Data\n Download"
  },
  {
    "objectID": "references.html",
    "href": "references.html",
    "title": "4  References",
    "section": "",
    "text": "Lamichhaney, Sangeet, Fan Han, Matthew T. Webster, B. Rosemary Grant,\nPeter R. Grant, and Leif Andersson. 2020. “Female-Biased Gene Flow\nBetween Two Species of Darwin’s Finches.” Nature Ecology\n& Evolution 4 (7): 979–86. https://doi.org/10.1038/s41559-020-1183-9.\n\n\nStevens, S. S. 1946. “On the Theory of Scales of\nMeasurement.” Science 103 (2684): 677–80. https://doi.org/10.1126/science.103.2684.677."
  },
  {
    "objectID": "materials/glm-intro-lm.html#data",
    "href": "materials/glm-intro-lm.html#data",
    "title": "\n5  Linear models\n",
    "section": "\n5.1 Data",
    "text": "5.1 Data\nFor this example, we’ll be using the finches data set."
  },
  {
    "objectID": "materials/glm-intro-lm.html#exploring-data",
    "href": "materials/glm-intro-lm.html#exploring-data",
    "title": "\n5  Linear models\n",
    "section": "\n5.2 Exploring data",
    "text": "5.2 Exploring data\nIt’s always a good idea to explore your data visually. Here we are focussing on the (potential) relationship between beak length (blength) and beak depth (bdepth).\nOur data contains measurements from two years (year) and two species (species). If we plot beak depth against beak length, colour our data by species and look across the two time points (1975 and 2012), we get the following graph:\n\n\n\n\nFigure 5.1: Beak depth and length for G. fortis and G. scandens\n\n\n\n\nIt seems that there is a potential linear relationship between beak depth and beak length. There are some differences between the two species and two time points with, what seems, more spread in the data in 2012. The data for both species also seem to be less separated than in 1975.\nFor the current purpose, we’ll focus on one group of data: those of Geospiza fortis in 1975."
  },
  {
    "objectID": "materials/glm-intro-lm.html#linear-model",
    "href": "materials/glm-intro-lm.html#linear-model",
    "title": "\n5  Linear models\n",
    "section": "\n5.3 Linear model",
    "text": "5.3 Linear model\nLet’s look at the G. fortis data more closely, assuming that the have a linear relationship. We can visualise that as follows:\n\n\n\n\nFigure 5.2: Beak depth vs beak length G. fortis (1975)\n\n\n\n\nIf you recall from the Core statistics linear regression session, what we’re doing here is assuming that there is a linear relationship between the response variable (in this case bdepth) and predictor variable (here, blength).\nWe can get more information on this linear relationship by defining a linear model, which has the form of:\n\\[\nY = \\beta_0 + \\beta_1X\n\\]\nwhere \\(Y\\) is the response variable (the thing we’re interested in), \\(X\\) the predictor variable and \\(\\beta_0\\) and \\(\\beta_1\\) are model coefficients. More explicitly for our data, we get:\n\\[\nbeak\\ depth = \\beta_0 + \\beta_1 \\times beak\\ length\n\\]\n\n\n\nBut how do we find this model? The computer uses a method called least-squares regression. There are several steps involved in this.\n\n5.3.1 Line of best fit\nThe computer tries to find the line of best fit. This is a linear line that best describes your data. We could draw a linear line through our cloud of data points in many ways, but the least-squares method converges to a single solution, where the sum of squared residual deviations is at its smallest.\nTo understand this a bit better, it’s helpful to realise that each data point consists of a fitted value (the beak depth predicted by the model at a given beak length), combined with the error. The error is the difference between the fitted value and the data point.\nLet’s look at this for one of the observations, for example finch 473:\n\n\n\n\nFigure 5.3: Beak depth vs beak length (finch 473, 1975)\n\n\n\n\nObtaining the fitted value and error happens for each data point. All these residuals are then squared (to ensure that they are positive), and added together. This is the so-called sum-of-squares.\nYou can imagine that if you draw a line through the data that doesn’t fit the data all that well, the error associated with each data point increases. The sum-of-squares then also increases. Equally, the closer the data are to the line, the smaller the error. This results in a smaller sum-of-squares.\nThe linear line where the sum-of-squares is at its smallest, is called the line of best fit. This line acts as a model for our data.\nFor finch 473 we have the following values:\n\nthe observed beak depth is 9.5 mm\nthe observed beak length is 10.5 mm\nthe fitted value is 9.11 mm\nthe error is 0.39 mm\n\n5.3.2 Linear regression\nOnce we have the line of best fit, we can perform a linear regression. What we’re doing with the regression, is asking:\n\nIs the line of best fit a better predictor of our data than a horizontal line across the average value?\n\nVisually, that looks like this:\n\n\n\n\nFigure 5.4: Regression: is the slope different from zero?\n\n\n\n\nWhat we’re actually testing is whether the slope (\\(\\beta_1\\)) of the line of best fit is any different from zero.\nTo find the answer, we perform an ANOVA. This gives us a p-value of 1.68e-78.\nNeedless to say, this p-value is extremely small, and definitely smaller than any common significance threshold, such as \\(p < 0.05\\). This suggests that beak length is a statistically significant predictor of beak depth.\nIn this case the model has an intercept (\\(\\beta_0\\)) of -0.34 and a slope (\\(\\beta_1\\)) of 0.9. We can use this to write a simple linear equation, describing our data. Remember that this takes the form of:\n\\[\nY = \\beta_0 + \\beta_1X\n\\]\nwhich in our case is\n\\[\nbeak\\ depth = \\beta_0 + \\beta_1 \\times beak\\ length\n\\]\nand gives us\n\\[\nbeak\\ depth = -0.34 + 0.90 \\times beak\\ length\n\\]\n\n5.3.3 Assumptions\nIn example above we just got on with things once we suspected that there was a linear relationship between beak depth and beak length. However, for the linear regression to be valid, several assumptions need to be met. If any of those assumptions are violated, we can’t trust the results. The following four assumptions need to be met, with a 5th point being a case of good scientific practice:\n\nData should be linear\nResiduals are normally distributed\nEquality of variance\nData are independent\n(no influential points)\n\nAs we did many times during the Core statistics sessions, we mainly rely on diagnostic plots to check these assumptions. For this particular model they look as follows:\n\n\n\n\nFigure 5.5: Diagnostic plots for G. fortis (1975) model\n\n\n\n\nThese plots look very good to me. For a recap on how to interpret these plots, see CS2: ANOVA.\nTaken together, we can see the relationship between beak depth and beak length as a linear one, described by a (linear) model that has a predicted value for each data point, and an associated error."
  },
  {
    "objectID": "materials/glm-intro-glm.html#putting-the-g-into-glm",
    "href": "materials/glm-intro-glm.html#putting-the-g-into-glm",
    "title": "\n6  Generalising your model\n",
    "section": "\n6.1 Putting the “G” into GLM",
    "text": "6.1 Putting the “G” into GLM\nIn the previous linear model example all the assumptions were met. But what if we have data where that isn’t the case? For example, what if we have data where we can’t describe the relationship between the predictor and response variables in a linear way?\nOne of the ways we can deal with this is by using a generalised linear model, also abbreviated as GLM. In a way it’s an extension of the linear model we discussed in the previous section. As with the normal linear model, the predictor variables in the model are in a linear combination, such as:\n\\[\n\\beta_0 + \\beta_1X_1 + \\beta_2X_2 + \\beta_3X_3 + ...\n\\]\nHere, the \\(\\beta_0\\) value is the constant or intercept, whereas each subsequent \\(\\beta_i\\) is a unique regression coefficient for each \\(X_i\\) predictor variable. So far so good.\nHowever, the GLM makes the linear model more flexible in two ways:\n\n\nIn a standard linear model the linear combination (e.g. like we see above) becomes the predicted outcome value. With a GLM a transformation is specified, which turns the linear combination into the predicted outcome value. This is called a link function.\nA standard linear model assumes a continuous, normally distributed outcome, whereas with GLM the outcome can be both continuous or integer. Furthermore, the outcome does not have to be normally distributed. Indeed, the outcome can follow a different kind of distribution, such as binomial, Poisson, exponential etc.\n\n\nWe’ll introduce each of these elements below, then illustrate how they are used in practice, using different types of data.\nThe link function and different distributions are closely…err, linked. So in order to make sense of what the link function is doing, it’s useful to understand better the different distributional assumptions. So we’ll start with those."
  },
  {
    "objectID": "materials/glm-intro-glm.html#distributions",
    "href": "materials/glm-intro-glm.html#distributions",
    "title": "\n6  Generalising your model\n",
    "section": "\n6.2 Distributions",
    "text": "6.2 Distributions\nIn the examples of a linear model we’ve seen that the residuals needed to be normally distributed. We’ve mainly used the Q-Q plot to assess this assumption of normality.\nBut what does “normal” actually mean? It assumes that the residuals are coming from a normal or Gaussian distribution. This distribution has a symmetrical bell-shape, where the centre is the mean, and half of the data are on either side of this.\nWe can see this in Figure 6.1. The mean of the normal distribution is indicated with the dashed blue line.\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6.1: Normal distribution\n\n\n\n\nWe can use the linear model we created previously, where we looked at the possible linear relationship between beak length and beak length. This is based on measurements of G. fortis beaks in 1975.\nThe individual values of the residuals from this linear model are shown in Figure 6.1, panel B (in red), with the corresponding theoretical normal distribution in the background. We can see that the residuals follow this distribution reasonably well, which matches our conclusions from the Q-Q plot (see Figure 5.5).\nAll this means is that assuming that these residuals may come from a normal distribution isn’t such a daft suggestion after all.\nNow look at this example:\n\n\n\n\n\n\n\n\n\n\n\n\n\nFigure 6.2: Classification in beak shape\n\n\n\n\nThe data in Figure 6.2 show the classification of beak shape for a collection of finches. They are either classed as blunt or pointed. Various (continuous) measurements were taken from each bird, with the beak length shown here.\nWe’ll look into this example in more detail later. For now it’s important to note that the response variable (class) is not continuous. In this case, it’s a binary response (blunt or pointed). As a result, the assumptions for a regular linear model go out of the window. If we were foolish enough to fit a linear model to these data, then the residuals would look rather non-normal (Figure 6.3).\n\n\n\n\n\n\nFigure 6.3: Beak class model residuals\n\n\n\n\nSo what do we do? Well, the normal distribution is not the only one there is. In Figure 6.4 there are a few examples of distributions (including the normal one).\n\n\n\n\nFigure 6.4: Different distributions\n\n\n\n\nDifferent distributions are useful for different types of data. For example, a logistic distribution is particularly useful in the context of binary or proportional response data. The Poisson distribution is useful when we’ve got count data.\nIn order to understand how this can help us, we need to be aware of two more concepts: linear predictors and link functions."
  },
  {
    "objectID": "materials/glm-intro-glm.html#linear-predictors",
    "href": "materials/glm-intro-glm.html#linear-predictors",
    "title": "\n6  Generalising your model\n",
    "section": "\n6.3 Linear predictors",
    "text": "6.3 Linear predictors\nThe nice thing about linear models is that the predictors are, well, linear. Straight lines make for easy interpretation of any potential relationship between predictor and response.\nAs mentioned before, predictors are in the form of a linear combination, where each predictor variable is multiplied by a coefficient and all the terms are added together:\n\\[\n\\beta_0 + \\beta_1X_1 + \\beta_2X_2 + \\beta_3X_3 + ...\n\\]\nFortunately, this is no different for generalised linear models! We still have a linear combination but, as we’ll see, if the relationship is not linear then we need an additional step before we can model the data.\nAt this point, we have two options at our disposal (well, there are more, but let’s not muddy the waters too much).\n\n\n\n\n\n\nImportant\n\n\n\n\nTransform our data and use a normal linear model on the transformed data\nUse a generalised linear model (GLM)\n\n\n\nThe first option, transforming our data, seems like a useful option and can work. It keeps things familiar (we’d still use a standard linear model) and so all is well with the world. Up to the point of interpreting the data. If we, for example, log-transform our data, how do we interpret this? After all, the predictions of the linear model are directly related to the outcome or response variable. Transforming the data is usually done so that the residuals of the linear model resemble a more normal distribution. An unwanted side-effect of this is that this also changes the ratio scale properties of the measured variables (Stevens 1946).\nThe second option would be to use a generalised linear model. Here we leave the data the same, and instead we transform the linear predictor. This enables us to map a non-linear outcome (or response variable) to a linear model. This transformation is done using a link function."
  },
  {
    "objectID": "materials/glm-intro-glm.html#link-functions",
    "href": "materials/glm-intro-glm.html#link-functions",
    "title": "\n6  Generalising your model\n",
    "section": "\n6.4 Link functions",
    "text": "6.4 Link functions\nRight, now we’ve got that out of the way, let’s illustrate this with an example. We’ll look at some data that come from an analysis of gene flow across two finch species (Lamichhaney et al. 2020).\nThe data focus on two species, Geospiza fortis and G. scandens. The measurements are split by a uniquely timed event: a particularly strong El Niño event in 1983. This event changed the vegetation and food supply of the finches, allowing F1 hybrids of the two species to survive, whereas before 1983 they could not. The measurements are classed as early (pre-1983) and late (1983 onwards).\n\n\n\n\n\n\nLet’s first look at the different groups:\n\n\n\n\nFigure 6.5: Beak classification pre- and post El Niño\n\n\n\n\nWe can see that in the early time point (pre-1983) both species had relatively distinct beak shapes. Generally, G. fortis had blunt beaks, whereas G. scandens had pointed beaks.\nAfter the 1983 El Niño event, some of the F1 hybrids between the two species survived which, over time, started to show intermediate beak shapes. There’s a lot more to this story, and we’ll come back to it later. For now, let’s say we were in a situation where we did not have the beak classification. but we did have the beak length measurements.\nCould we make some predictions about how likely a given measurement would be classified as blunt or pointed? Let’s focus on just the early time points, where the effect is most pronounced. This is visualised in Figure 6.6, A.\n\n\n\n\nFigure 6.6: Beak classification without class information\n\n\n\n\nWe could then try to model this with the knowledge we’ve got so far and perform a linear regression analysis, the results of which are in Figure 6.6, B.\nThis is really bad practice. Why? Well, the linear model suggests that it is possible to have a higher than 100%, and lower-than-zero, probability that a beak would be pointed! That, makes no sense. So, we can’t describe these data with some kind of linear relationship.\nInstead, we’ll use a logistic model to analyse these data. We’ll cover the practicalities of how to do this in more detail in a later chapter, but for now it’s sufficient to realise that one of the ways we could model these data could look like this:\n\n\n\n\nFigure 6.7: Logistic model for beak classification\n\n\n\n\nThis sigmoidal curve at least ensures that our predicted probabilities do not exceed the \\([0, 1]\\) range.\nNow, what happened behind the scenes is that the generalised linear model has taken the linear predictor and transformed it using the logit function. This links the linear predictor to the non-linear outcome (or response). Conversely, we can look at the fitted values of the model (before they get transformed). They look like this:\n\n\n\n\nFigure 6.8: Fitted values for beak classification\n\n\n\n\nAs we can see, the values predicted by the model are still on a linear scale!\nThe fitted model values are linear because the non-linear outcome (the relationship between beak length and beak classification) is linearised by the model, through the link function.\nIn this case we’ve used the logit link function (more on this later). So the values we’re seeing are on a logit scale. If we wanted to visualise the actual probabilities, we could do that as follows (also displaying the model predictions as a dashed line for clarity):\n\n\n\n\nFigure 6.9: Predicted probabilities for beak classification\n\n\n\n\nFrom this we can see that the probability of having a pointed beak (which is considered a “success”) is approaching 1 as the beak length gets longer.\nWhat about the residuals of the model? If all is well, then the residuals should, following the transformation, approach normality.\n\n\n\n\nFigure 6.10: Residuals before and after link function\n\n\n\n\nThis is displayed in Figure 6.10. We can see the original residuals (based on the standard linear model) in Figure 6.10, A. We’ve seen these before, with the corresponding hypothetical normal distribution in the background for comparison. The residuals look markedly different to a normal distribution!\nIn contrast, the residuals of the generalised linear model we created, via the link function, are in Figure 6.10, B. They are not perfect, but clearly much improved!"
  },
  {
    "objectID": "materials/glm-intro-glm.html#key-points",
    "href": "materials/glm-intro-glm.html#key-points",
    "title": "\n6  Generalising your model\n",
    "section": "\n6.5 Key points",
    "text": "6.5 Key points\n\n\n\n\n\n\nNote\n\n\n\n\nGLMs allow us to map a non-linear outcome to a linear model\nThe link function determines how this occurs, transforming the linear predictor\n\n\n\n\n\n\n\nLamichhaney, Sangeet, Fan Han, Matthew T. Webster, B. Rosemary Grant, Peter R. Grant, and Leif Andersson. 2020. “Female-Biased Gene Flow Between Two Species of Darwin’s Finches.” Nature Ecology & Evolution 4 (7): 979–86. https://doi.org/10.1038/s41559-020-1183-9.\n\n\nStevens, S. S. 1946. “On the Theory of Scales of Measurement.” Science 103 (2684): 677–80. https://doi.org/10.1126/science.103.2684.677."
  },
  {
    "objectID": "materials/glm-practical-logistic-binary.html#libraries-and-functions",
    "href": "materials/glm-practical-logistic-binary.html#libraries-and-functions",
    "title": "\n7  Binary response\n",
    "section": "\n7.1 Libraries and functions",
    "text": "7.1 Libraries and functions\n\n\n\n\n\n\nClick to expand\n\n\n\n\n\n\n\nR\nPython\n\n\n\n\n7.1.1 Libraries\n\n7.1.2 Functions\n\n\n\n\n7.1.3 Libraries\n\n# A Python data analysis and manipulation tool\nimport pandas as pd\n\n# Python equivalent of `ggplot2`\nfrom plotnine import *\n\n# Statistical models, conducting tests and statistical data exploration\nimport statsmodels.api as sm\n\n# Convenience interface for specifying models using formula strings and DataFrames\nimport statsmodels.formula.api as smf\n\n\n7.1.4 Functions\n\n\n\n\n\n\n\nThe example in this section uses the following data set:\ndata/diabetes.csv\nThis is a data set comprising 768 observations of three variables (one dependent and two predictor variables). This records the results of a diabetes test result as a binary variable (1 is a positive result, 0 is a negative result), along with the result of a glucose test and the diastolic blood pressure for each of 767 women. The variables are called test_result, glucose and diastolic."
  },
  {
    "objectID": "materials/glm-practical-logistic-binary.html#load-and-visualise-the-data",
    "href": "materials/glm-practical-logistic-binary.html#load-and-visualise-the-data",
    "title": "\n7  Binary response\n",
    "section": "\n7.2 Load and visualise the data",
    "text": "7.2 Load and visualise the data\nFirst we load the data, then we visualise it.\n\n\nR\nPython\n\n\n\n\ndiabetes <- read_csv(\"data/diabetes.csv\")\n\n\n\n\ndiabetes_py = pd.read_csv(\"data/diabetes.csv\")\n\n\n\n\nLooking at the data, we can see that the test_result column contains zeros and ones. These are yes/no test result outcomes and not actually numeric representations.\nWe’ll have to deal with this soon. For now, we can plot the data, by outcome:\n\n\nR\nPython\n\n\n\n\ndiabetes %>% \n  ggplot(aes(x = factor(test_result),\n             y = glucose)) +\n  geom_boxplot()\n\n\n\n\n\n\nWe could just give Python the test_result data directly, but then it would view the values as numeric. Which doesn’t really work, because we have two groups as such: those with a negative diabetes test result, and those with a positive one.\nWe can force Python to temporarily covert the data to a factor, by making the test_result column an object type. We can do this directly inside the ggplot() function.\n\n(ggplot(diabetes_py,\n         aes(x = diabetes_py.test_result.astype(object),\n             y = \"glucose\")) +\n     geom_boxplot())\n\n\n\n\n\n\n\nIt looks as though the patients with a positive diabetes test have slightly higher glucose levels than those with a negative diabetes test.\nWe can visualise that differently by plotting all the data points as a classic binary response plot:\n\n\nR\nPython\n\n\n\n\ndiabetes %>% \n  ggplot(aes(x = glucose, y = test_result)) +\n  geom_point()\n\n\n\n\n\n\n\n(ggplot(diabetes_py,\n         aes(x = \"glucose\",\n             y = \"test_result\")) +\n     geom_point())\n\n\n\n\n\n\n\nThis presents us with a bit of an issue. We could fit a linear regression model to these data, although we already know that this is a bad idea…\n\n\nR\nPython\n\n\n\n\ndiabetes %>% \n  ggplot(aes(x = glucose, y = test_result)) +\n  geom_point() +\n  geom_smooth(method = \"lm\")\n\n\n\n\n\n\n\n(ggplot(diabetes_py,\n         aes(x = \"glucose\",\n             y = \"test_result\")) +\n     geom_point() +\n     geom_smooth(method = \"lm\",\n                 colour = \"blue\"))\n\n\n\n\n\n\n\nOf course this is rubbish - we can’t have test results outside the range of [0, 1].\nBut for the sake of exploration, let’s look at the assumptions:\n\n\nR\nPython\n\n\n\n\nlm_dia <- lm(test_result ~ glucose,\n             data = diabetes)\n\nlm_dia %>% \n  resid_panel(plots = c(\"resid\", \"qq\", \"ls\", \"cookd\"),\n              smoother = TRUE)\n\n`geom_smooth()` using formula 'y ~ x'\n`geom_smooth()` using formula 'y ~ x'\n\n\n\n\n\n\n\nFirst, we create a linear model:\n\n# create a linear model\nmodel = smf.ols(formula= \"test_result ~ glucose\",\n                data = diabetes_py)\n# and get the fitted parameters of the model\nlm_dia_py = model.fit()\n\nNext, we can create the diagnostic plots:\n\ndgplots(lm_dia_py)\n\n\n\n\n\n\n\n\n\n\n\n\nThey’re pretty extremely bad.\n\nThe response is not linear (Residual Plot, binary response plot, common sense).\nThe residuals are not distributed normally (Q-Q Plot)\nThe variance is not homogeneous across the predicted values (Location-Scale Plot)\nBut - there is always a silver lining - we don’t have influential data points.\n\n\n\n\n\n\n\nViewing residuals\n\n\n\nAnother way of viewing the residuals (apart from the Q-Q plot) is as a dot-plot. In R, the ggdist and distributional packages are extremely useful for this kind of stuff.\nWhat I’m doing here is:\n\ndefine the model\ncreate a normal distribution with \\(\\mu = 0\\) and \\(\\sigma = 0.415\\) (I’ve extracted the \\(\\sigma\\) value from the residuals with rstatix::get_summary_stats())\nplot the residuals\n\n\ndiabetes %>% \n  lm(test_result ~ glucose, data = .) %>%\n  resid() %>%\n  as_tibble() %>%\n  # rstatix::get_summary_stats()\n  ggplot(aes(x = value)) +\n  stat_dist_halfeye(aes(dist = dist_normal(0, 0.415)),\n                    orientation = \"horizontal\") +\n  stat_dotsinterval(aes(x = value),\n                    orientation = \"horizontal\",\n                    fill = \"firebrick\", scale = 1) +\n  labs(title = \"Linear model (diabetes)\", y = \"probability\", x = NULL)\n\n\n\n\nThis again shows us that the residuals are really not normally distributed. If they were, then they would overlap much more closely with the distribution (in grey)."
  },
  {
    "objectID": "materials/glm-practical-logistic-binary.html#creating-a-suitable-model",
    "href": "materials/glm-practical-logistic-binary.html#creating-a-suitable-model",
    "title": "\n7  Binary response\n",
    "section": "\n7.3 Creating a suitable model",
    "text": "7.3 Creating a suitable model\nSo far we’ve established that using a simple linear model to describe a potential relationship between glucose levels and the probability of getting a positive test result is not a good idea. So, what can we do?\nOne of the ways we can deal with binary outcome data is by performing a logistic regression. Instead of fitting a straight line to our data, and performing a regression on that, we fit a line that has an S shape. This avoids the model making predictions outside the \\([0, 1]\\) range.\nThere are many mathematical functions that produce S-shaped graphs. The logistic function is one of them and well-suited to these kind of data.\nIn the most simple form a logistic function is written like this:\n\\(Y = \\frac{\\exp(X)}{1 + \\exp(X)}\\)\n\n\n\n\n\n\nEuler’s number\n\n\n\nIn mathematics, \\(\\rm e\\) represents a constant of around 2.718. Another notation is \\(\\exp\\), which is often used when notations become a bit cumbersome. Here, I exclusively use the \\(\\exp\\) notation for consistency.\n\n\nWe can generalise this, by writing it as follows:\n\\(Y = \\frac{\\exp(X)}{1 + \\exp(\\beta_0 + \\beta_1X)}\\)\nNote that the \\(\\beta_0 + \\beta_1X\\) part is identical to the formula of a straight line. We’ve come across this before when we were doing simple linear regression!\nThe rest of the function is what makes the straight line curve into its characteristic S shape. The middle of the S (where \\(Y = 0.5\\)) occurs when \\(X = \\frac{-a}{b}\\).\n\n\n\n\n\n\nThe logistic function\n\n\n\nThe shape of the logistic function is hugely influenced by the different parameters, in particular \\(\\beta_1\\). The plots below show different situations, where \\(\\beta_0 = 0\\) in all cases, but \\(\\beta_1\\) varies.\nThe first plot shows the logistic function in its simplest form, with the others showing the effect of varying \\(\\beta_1\\).\n\n\n\n\n\n\nwhen \\(\\beta_1 = 1\\), this gives the simplest logistic function\nwhen \\(\\beta_1 = 0\\) gives a horizontal line, with \\(Y = \\frac{\\exp(\\beta_0)}{1+\\exp(\\beta_0)}\\)\n\nwhen \\(\\beta_1\\) is negative flips the curve around, so it slopes down\nwhen \\(\\beta_1\\) is very large then the curve becomes extremely steep\n\n\n\nWe can fit such an S-shaped curve to our diabetes data set, by creating a generalised linear model.\n\n\nR\nPython\n\n\n\nIn R we have a few options to do this, and by far the most familiar function would be glm(). Here we save the model in an object called glm_dia:\n\nglm_dia <- glm(test_result ~ glucose,\n               family = binomial,\n               data = diabetes)\n\nThe format of this function is similar to that used by the lm() function for linear models. The important difference is that we must specify the family of error distribution to use. For logistic regression we must set the family to binomial.\nIf you forget to set the family argument, then the glm() function will perform a standard linear model fit, identical to what the lm() function would do.\n\n\n\n# create a linear model\nmodel = smf.glm(formula= \"test_result ~ glucose\",\n                family = sm.families.Binomial(),\n                data = diabetes_py)\n# and get the fitted parameters of the model\nglm_dia_py = model.fit()"
  },
  {
    "objectID": "materials/glm-practical-logistic-binary.html#model-output",
    "href": "materials/glm-practical-logistic-binary.html#model-output",
    "title": "\n7  Binary response\n",
    "section": "\n7.4 Model output",
    "text": "7.4 Model output\nThat’s the easy part done! The trickier part is interpreting the output. First of all, we’ll get some summary information.\n\n\nR\nPython\n\n\n\n\nsummary(glm_dia)\n\n\nCall:\nglm(formula = test_result ~ glucose, family = binomial, data = diabetes)\n\nDeviance Residuals: \n    Min       1Q   Median       3Q      Max  \n-2.1353  -0.7819  -0.5189   0.8269   2.2832  \n\nCoefficients:\n             Estimate Std. Error z value Pr(>|z|)    \n(Intercept) -5.611732   0.442289  -12.69   <2e-16 ***\nglucose      0.039510   0.003398   11.63   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for binomial family taken to be 1)\n\n    Null deviance: 936.6  on 727  degrees of freedom\nResidual deviance: 752.2  on 726  degrees of freedom\nAIC: 756.2\n\nNumber of Fisher Scoring iterations: 4\n\n\n\n\n\nprint(glm_dia_py.summary())\n\n                 Generalized Linear Model Regression Results                  \n==============================================================================\nDep. Variable:            test_result   No. Observations:                  728\nModel:                            GLM   Df Residuals:                      726\nModel Family:                Binomial   Df Model:                            1\nLink Function:                  Logit   Scale:                          1.0000\nMethod:                          IRLS   Log-Likelihood:                -376.10\nDate:                Mon, 06 Mar 2023   Deviance:                       752.20\nTime:                        08:43:52   Pearson chi2:                     713.\nNo. Iterations:                     4   Pseudo R-squ. (CS):             0.2238\nCovariance Type:            nonrobust                                         \n==============================================================================\n                 coef    std err          z      P>|z|      [0.025      0.975]\n------------------------------------------------------------------------------\nIntercept     -5.6117      0.442    -12.688      0.000      -6.479      -4.745\nglucose        0.0395      0.003     11.628      0.000       0.033       0.046\n==============================================================================\n\n\n\n\n\nThere’s a lot to unpack here so take a deep breath (or make sure you have a coffee) before continuing…\n\n\nR\nPython\n\n\n\n\nThe first lines just confirm which model we’ve been fitting (trust me, this can be useful when you’re in the middle of a load of analysis and you’ve lost track of what the hell is going on!)\nThe next block is called Deviance Residuals. This isn’t particularly useful, but just so you know: for linear models the residuals were calculated for each data point and then squared and added up to get the SS (sum of squares), which is used to fit the model. For generalised linear models we don’t use SS to fit the model and instead we use an entirely different method called maximum likelihood. This fitting procedure generates a different quantity, called Deviance, which is the analogue of SS. A deviance of zero indicates the best model we could hope for and bigger values indicate a model that doesn’t fit quite as well. The deviance residuals are then values associated with each data point, that when squared and summed give the deviance for the model (an exact analogy to normal residuals). You’re unlikely to ever need to know this, but I had some time on my hands and decided to share this little nugget with you :-)\nThe Coefficients block is next. The main numbers to extract from the output are the two numbers underneath Estimate.Std:\n\n(Intercept)  -5.611732\nglucose      0.039510\n\n\nThe top part of table contains a lot of information about the model we’ve just created at a high level. The left-hand column just tells us a lot of stuff that we really don’t care about like:\n\nthe name of the dependent variable (which we already know because we entered it ourselves!);\nthe type of model (a binomial glm which we again already knew).\nthe type of link function (in this case a logit link – we don’t really care about this either).\nGeneralized Linear Models don’t have exact analytical methods for fitting to the data and they all use some form of iterative algorithm. In this case we used the standard method called Iteratively Reweighted Least Squares (IRLS),\nand the model took 4 iterations to converge.\nThis left-hand column also helpfully tells us the time and date when the analysis was carried out – how helpful!\n\nThe right-hand column starts to give us some more useful summary statistics that we’ll end up using. In particular we care about the Deviance value. For linear models the residuals were calculated for each data point and then squared and added up to get the SS (sum of squares), which is used to fit the model. For generalised linear models we don’t use SS to fit the model and instead we use an entirely different method called maximum likelihood. This fitting procedure generates a different quantity, called Deviance, which is the analogue of SS. A deviance of zero indicates the best model we could hope for (basically that the model completely matches the data) and bigger values indicate a model that doesn’t fit quite as well. We’ll also need the Df residuals value here (degrees of freedom) for some later calculations.\nRight at the bottom is a table showing the model coefficients. The main numbers to extract from the output are the two numbers in the coef column:\n======================\n                 coef\n----------------------\nIntercept     -5.6117\nglucose        0.0395\n======================\n\n\n\nThese are the coefficients of the logistic model equation and need to be placed in the correct equation if we want to be able to actually calculate the probability of having a positive diabetes test for a given glucose level.\nThe p values (Pr(>|z|) at the end of each coefficient row merely show whether that particular coefficient is significantly different from zero. This is similar to the p-values obtained in the summary output of a linear model, and as before, for continuous predictors in simple models these p-values can be used to decide whether that predictor is important (so in this case glucose appears to be significant). However, these p-values aren’t great when we have multiple predictor variables, or when we have categorical predictors with multiple levels (since the output will give us a p-value for each level rather than for the predictor as a whole).\nWe can use the coefficients to actually calculate the probability of having a positive diabetes test for a given glucose level:\n\\[ P(positive \\ test\\ result) = \\frac{\\exp(-5.61 + 0.04 \\times glucose)}{1 + \\exp(-5.61 + 0.04 \\times glucose)} \\]\n\n\n\n\n\n\nExpanded explanation\n\n\n\n\n\nWe started with:\n\nOur linear predictor equation \\[logit(p) = \\beta_0 + \\beta_1 x_1 + ... + \\beta_p x_p\\]\nand link function \\[logit(p) = log(\\frac{p}{1 - p})\\]\n\nOur coefficients are as follows:\n\n\n\n\n\n\ncoefficient\nvalue\n\n\n\n\\(\\beta_0\\)\n-5.6117317\n\n\n\\(\\beta_1\\)\n0.0395101\n\n\n\nWhich means that we can write the linear predictor equation as follows:\n\\[logit(p) = -5.61 + 0.04 \\times glucose\\] We still have to take into account our link function. Combining the two equations gives us:\n\\[log(\\frac{p}{1 - p}) = -5.61 + 0.04 \\times glucose\\]\nTo get our \\(p\\) (the probability of a person having a positive diabetes test result), we need to exponentiate our equation:\n\\[\\frac{p}{1 - p} = \\exp{(-5.61 + 0.04 \\times glucose)}\\]\nleading to…\n\\[p = \\frac{\\exp{(-5.61 + 0.04 \\times glucose)}}{1 + \\exp{(-5.61 + 0.04 \\times glucose)}}\\]\n\n\n\n\n\nR\nPython\n\n\n\n\nThe next line tells us that the dispersion parameter was assumed to be 1 for this binomial model. Dispersion is a property that says whether the data were more or less spread out around the logistic curve than we would expect. A dispersion parameter of 1 says that the data are spread out exactly as we would expect. Greater than 1 is called over-dispersion and less than 1 is called under-dispersion. Here this line is saying that when we fitted this model, we were assuming that the dispersion of the data was exactly 1. For binary data, like we have here, the data cannot be over or under-dispersed but this is something that we’ll need to check for other sorts of glms.\n\nThe last three lines relate to quantities called deviance and AIC (Akaike Information Criterion).\nAs we said just above, the deviance values are the equivalent of Sums of Squares values in linear models (and are a product of the technique used to fit the curve to the data). They can be used as a metric of goodness of fit for the model, with a deviance of 0 indicating a perfect fitting model. The deviance for the null model (i.e. the model without any predictors, basically saying that the probability of getting a positive diabetes score is constant and doesn’t depend on glucose level) is given by the first line and the deviance for the actual model is given by the residual deviance line. We will see how we can use the deviance to do two things.\n\nto check of whether the model is actually any good (i.e. does it in any way look like it’s close to the data). This is akin to what we were doing with \\(R^2\\) values in linear models.\nto check if the model we’ve specified is better than the null model.\n\nIt’s important to realise that these two things can be independent of each other; we can have a model that is significantly better than a null model whilst still being rubbish overall (the null model will have been even more rubbish in comparison), and we can have a model that is brilliant yet still not be better than the null model (in this case the null model was already brilliant).\nAs we found in the model comparisons practical, the AIC value is meaningless by itself, but it will allow us to compare this model to another model with different terms (with the model with the smaller AIC value being the better fitting model).\n\n\nThere are some additional parameters in the right-hand column, but we’ll first focus on how we can assess significance."
  },
  {
    "objectID": "materials/glm-practical-logistic-binary.html#assessing-significance",
    "href": "materials/glm-practical-logistic-binary.html#assessing-significance",
    "title": "\n7  Binary response\n",
    "section": "\n7.5 Assessing significance",
    "text": "7.5 Assessing significance\n\n\nR\nPython"
  },
  {
    "objectID": "materials/glm-practical-logistic-binary.html#exercise",
    "href": "materials/glm-practical-logistic-binary.html#exercise",
    "title": "\n7  Binary response\n",
    "section": "\n7.6 Exercise",
    "text": "7.6 Exercise\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n\nR\nPython"
  },
  {
    "objectID": "materials/glm-practical-logistic-binary.html#key-points",
    "href": "materials/glm-practical-logistic-binary.html#key-points",
    "title": "\n7  Binary response\n",
    "section": "\n7.7 Key points",
    "text": "7.7 Key points\n\n\n\n\n\n\nNote\n\n\n\n\nWe use a logistic regression to model a binary response\nWe can feed new observations into the model and get probabilities for the outcome"
  },
  {
    "objectID": "materials/glm-practical-logistic-proportion.html#libraries-and-functions",
    "href": "materials/glm-practical-logistic-proportion.html#libraries-and-functions",
    "title": "\n8  Proportional response\n",
    "section": "\n8.1 Libraries and functions",
    "text": "8.1 Libraries and functions\n\ntidyverse\n\n\n\n\n\n\n\n\nLibrary\nDescription\n\n\n\ntidyverse\nA collection of R packages designed for data science\n\n\ntidymodels\nA collection of packages for modelling and machine learning using tidyverse principles"
  },
  {
    "objectID": "materials/glm-practical-logistic-proportion.html#datasets",
    "href": "materials/glm-practical-logistic-proportion.html#datasets",
    "title": "\n8  Proportional response\n",
    "section": "\n8.2 Datasets",
    "text": "8.2 Datasets\n\nChallenger\n\n\nThe example in this section uses the following data set:\ndata/challenger.csv\nThese data, obtained from the faraway package, contain information related to the explosion of the USA Space Shuttle Challenger on 28 January, 1986. An investigation after the disaster traced back to certain joints on one of the two solid booster rockets, each containing O-rings that ensured no exhaust gases could escape from the booster.\nThe night before the launch was unusually cold, with temperatures below freezing. The final report suggested that the cold snap during the night made the o-rings stiff, and unable to adjust to changes in pressure. As a result, exhaust gases leaked away from the solid booster rockets, causing one of them to break loose and rupture the main fuel tank, leading to the final explosion.\nThe question we’re trying to answer in this session is: based on the data from the previous flights, would it have been possible to predict the failure of most o-rings on the Challenger flight?"
  },
  {
    "objectID": "materials/glm-practical-logistic-proportion.html#visualise-the-data",
    "href": "materials/glm-practical-logistic-proportion.html#visualise-the-data",
    "title": "\n8  Proportional response\n",
    "section": "\n8.3 Visualise the data",
    "text": "8.3 Visualise the data\nFirst, we read in the data:\n\ntidyverse\n\n\n\nchallenger <- read_csv(\"data/challenger.csv\")\n\nRows: 23 Columns: 2\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\ndbl (2): temp, damage\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\nchallenger\n\n# A tibble: 23 × 2\n    temp damage\n   <dbl>  <dbl>\n 1    53      5\n 2    57      1\n 3    58      1\n 4    63      1\n 5    66      0\n 6    67      0\n 7    67      0\n 8    67      0\n 9    68      0\n10    69      0\n# … with 13 more rows\n\n\n\n\n\nThe data set contains several columns:\n\n\ntemp, the launch temperature in degrees Fahrenheit\n\ndamage, the number of o-rings that showed erosion\n\nBefore we have a further look at the data, let’s calculate the proportion of damaged o-rings (prop_damaged) and the total number of o-rings (total) and update our data set.\n\ntidyverse\n\n\n\nchallenger <-\nchallenger %>%\n  mutate(total = 6,                     # total number of o-rings\n         intact = 6 - damage,           # number of undamaged o-rings\n         prop_damaged = damage / total) # proportion damaged o-rings\n\nchallenger\n\n# A tibble: 23 × 5\n    temp damage total intact prop_damaged\n   <dbl>  <dbl> <dbl>  <dbl>        <dbl>\n 1    53      5     6      1        0.833\n 2    57      1     6      5        0.167\n 3    58      1     6      5        0.167\n 4    63      1     6      5        0.167\n 5    66      0     6      6        0    \n 6    67      0     6      6        0    \n 7    67      0     6      6        0    \n 8    67      0     6      6        0    \n 9    68      0     6      6        0    \n10    69      0     6      6        0    \n# … with 13 more rows\n\n\n\n\n\nPlotting the proportion of damaged o-rings against the launch temperature shows the following picture:\n\ntidyverse\n\n\n\nggplot(challenger, aes(x = temp, y = prop_damaged)) +\n  geom_point()\n\n\n\n\n\n\n\nThe point on the left is the data point corresponding to the coldest flight experienced before the disaster, where five damaged o-rings were found. Fortunately, this did not result in a disaster.\nHere we’ll explore if we could have predicted the failure of both o-rings on the Challenger flight, where the launch temperature was 31 degrees Fahrenheit."
  },
  {
    "objectID": "materials/glm-practical-logistic-proportion.html#model-building",
    "href": "materials/glm-practical-logistic-proportion.html#model-building",
    "title": "\n8  Proportional response\n",
    "section": "\n8.4 Model building",
    "text": "8.4 Model building\nWe only have 23 data points in total. So we’re building a model on not that much data - we should keep this in mind when we draw our conclusions!\n\ntidyverse\n\n\nWe are using a logistic regression for a proportion response in this case, since we’re interested in the proportion of o-rings that are damaged.\nThe logistic_reg() function we used in the binary response section does not work here, because it expects a binary (yes/no; positive/negative; 0/1 etc) response.\nTo deal with that, we are using the standard linear_reg() function, still using the glm or generalised linear model engine, with the family or error distribution set to binomial (as before).\nFirst we set the model specification:\n\nchl_mod <- linear_reg(mode = \"regression\") %>%\n  set_engine(\"glm\", family = \"binomial\")\n\nThen we fit the data. Fitting the data for proportion responses is a bit annoying, where you have to give the glm model a two-column matrix to specify the response variable.\nHere, the first column corresponds to the number of damaged o-rings, whereas the second column refers to the number of intact o-rings. We use the cbind() function to bind these two together into a matrix.\n\nchl_fit <- chl_mod %>% \n  fit(cbind(damage, intact) ~ temp,\n      data = challenger)\n\nNext, we can have a closer look at the results:\n\nchl_fit %>% tidy()\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic   p.value\n  <chr>          <dbl>     <dbl>     <dbl>     <dbl>\n1 (Intercept)   11.7      3.30        3.54 0.000403 \n2 temp          -0.216    0.0532     -4.07 0.0000478\n\n\nWe can see that the p-values of the intercept and temp are significant. We can also use the intercept and temp coefficients to construct the logistic equation, which we can use to sketch the logistic curve.\n\\[E(prop \\ failed\\ orings) = \\frac{\\exp{(11.66 -  0.22 \\times temp)}}{1 + \\exp{(11.66 -  0.22 \\times temp)}}\\]\nLet’s see how well our model would have performed if we would have fed it the data from the ill-fated Challenger launch.\nOne way of doing this it to generate a table with data for a range of temperatures, from 25 to 85 degrees Fahrenheit, in steps of 1. We can then use these data to generate the logistic curve, based on the fitted model.\n\nmodel <- tibble(temp = seq(25, 85, 1))\n\n\n# get the predicted proportions for the curve\ncurve <- chl_fit %>% augment(new_data = model)\n\n# plot the curve and the original data\nggplot(curve, aes(temp, .pred)) +\n  geom_line(colour = \"red\") +\n  geom_point(data = challenger, aes(temp, prop_damaged)) +\n  # add a vertical line at the disaster launch temperature\n  geom_vline(xintercept = 31, linetype = \"dashed\")\n\n\n\n\nIt seems that there was a high probability of both o-rings failing at that launch temperature. One thing that the graph shows is that there is a lot of uncertainty involved in this model."
  },
  {
    "objectID": "materials/glm-practical-logistic-proportion.html#exercise---predicting-failure",
    "href": "materials/glm-practical-logistic-proportion.html#exercise---predicting-failure",
    "title": "\n8  Proportional response\n",
    "section": "\n8.5 Exercise - predicting failure",
    "text": "8.5 Exercise - predicting failure\nThe data point at 53 degrees Fahrenheit is quite influential for the analysis. Remove this data point and repeat the analysis. Is there still a predicted link between launch temperature and o-ring failure?\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\ntidyverse\n\n\nFirst, we need to remove the influential data point:\n\nchallenger_new <- challenger %>% filter(temp != 53)\n\nWe can reuse the model specification, but we do have to update our fit:\n\nchl_new_fit <- chl_mod %>% \n  fit(cbind(damage, intact) ~ temp,\n      data = challenger_new)\n\n\n# get the predicted proportions for the curve\ncurve_new <- chl_new_fit %>% augment(new_data = model)\n\n# plot the curve and the original data\nggplot(curve_new, aes(temp, .pred)) +\n  geom_line(colour = \"red\") +\n  geom_point(data = challenger_new, aes(temp, prop_damaged)) +\n  # add a vertical line at the disaster launch temperature\n  geom_vline(xintercept = 31, linetype = \"dashed\")\n\n\n\n\nThe prediction proportion of damaged o-rings is markedly less in this scenario, with a failure rate of around 80%. The original fitted curve already had quite some uncertainty associated with it, but the uncertainty of this model is much greater."
  },
  {
    "objectID": "materials/glm-practical-logistic-proportion.html#key-points",
    "href": "materials/glm-practical-logistic-proportion.html#key-points",
    "title": "\n8  Proportional response\n",
    "section": "\n8.6 Key points",
    "text": "8.6 Key points\n\n\n\n\n\n\nNote\n\n\n\n\nWe can use a logistic model for proportion response variables"
  },
  {
    "objectID": "materials/glm-practical-poisson.html#libraries-and-functions",
    "href": "materials/glm-practical-poisson.html#libraries-and-functions",
    "title": "\n9  Poisson regression\n",
    "section": "\n9.1 Libraries and functions",
    "text": "9.1 Libraries and functions\n\ntidyverse\n\n\n\n\n\n\n\n\nLibrary\nDescription\n\n\n\ntidyverse\nA collection of R packages designed for data science\n\n\ntidymodels\nA collection of packages for modelling and machine learning using tidyverse principles\n\n\npoissonreg\nEnables the parsnip package to fit various types of Poisson regression models"
  },
  {
    "objectID": "materials/glm-practical-poisson.html#datasets",
    "href": "materials/glm-practical-poisson.html#datasets",
    "title": "\n9  Poisson regression\n",
    "section": "\n9.2 Datasets",
    "text": "9.2 Datasets\n\n\nIslands\nSeatbelts\n\n\n\nThe example in this section uses the following data set:\ndata/islands.csv\nThis is a data set comprising 35 observations of two variables (one dependent and one predictor). This records the number of species recorded on different small islands along with the area (km2) of the islands. The variables are species and area.\n\n\nThe seatbelts data set is a multiple time-series data set that was commissioned by the Department of Transport in 1984 to measure differences in deaths before and after front seatbelt legislation was introduced on 31st January 1983. It provides monthly total numerical data on a number of incidents including those related to death and injury in Road Traffic Accidents (RTA’s). The data set starts in January 1969 and observations run until December 1984.\nYou can find the file in data/seatbelts.csv"
  },
  {
    "objectID": "materials/glm-practical-poisson.html#visualise-the-data",
    "href": "materials/glm-practical-poisson.html#visualise-the-data",
    "title": "\n9  Poisson regression\n",
    "section": "\n9.3 Visualise the data",
    "text": "9.3 Visualise the data\nA good first step is always to explore your data prior to any further analysis.\n\ntidyverse\n\n\nFirst, we load and inspect the data:\n\nislands <- read_csv(\"data/island.csv\")\n\nislands\n\n# A tibble: 35 × 2\n   species  area\n     <dbl> <dbl>\n 1     114  12.1\n 2     130  13.4\n 3     113  13.7\n 4     109  14.5\n 5     118  16.8\n 6     136  19.0\n 7     149  19.6\n 8     162  20.6\n 9     145  20.9\n10     148  21.0\n# … with 25 more rows\n\n\nLooking at the data, we can see that there are two columns: species, which contains the number of species recorded on each island and area, which contains the surface area of the island in square kilometers.\nWe can plot the data:\n\nislands %>% \n  ggplot(aes(x = area, y = species)) +\n  geom_point()\n\n\n\n\n\n\n\nIt looks as though area may have an effect on the number of species that we observe on each island. We note that the response variable is count data and so we try to construct a Poisson regression."
  },
  {
    "objectID": "materials/glm-practical-poisson.html#model-building",
    "href": "materials/glm-practical-poisson.html#model-building",
    "title": "\n9  Poisson regression\n",
    "section": "\n9.4 Model building",
    "text": "9.4 Model building\nTo create a poisson regression we do the following:\n\ntidyverse\n\n\nAgain, similar to what we’ve done for the logistic models, we will use the parsnip package from the tidymodels library. Yes, the workflow still seems a bit faffy, but it provides a common syntax for a whole range of modelling libraries. This means that the syntax will stay the same as you do different kind of model comparisons.\nIf you haven’t loaded tidymodels yet, now is a really good time. We also need to load poissonreg, which adds extra functionality to parsnip.\n\n# install.packages(\"tidymodels\")\nlibrary(tidymodels)\n# install.packages(\"poissonreg\")\nlibrary(poissonreg)\n\nRemember that the workflow in parsnip is a bit different to what we’re used to so far. Using parsnip we approach things in a more systematic manner. We specify a model in three steps:\n\n\nSpecify the type of model based on its mathematical structure (e.g., linear regression, logistic regression, poisson regression etc).\n\nFor example:\n\n\nlinear_reg() for linear regression\n\nlogistic_reg() for logistic regression\n\npoisson_reg() for poisson regression (we’ll be using that here)\n\n\nWhen required, declare the mode of the model. The mode reflects the type of prediction outcome. For numeric outcomes, the mode is regression; for qualitative outcomes, it is classification. If a model can only create one type of model, such as poisson regression, the mode is already set to, in this case, mode = \"regression\".\nSpecify the engine for fitting the model. This usually is the software package or library that should be used.\n\nFor example,\n\n\n\"lm\" for linear models\n\n\"glm\" for generalised linear models\n\n\"stan\" for Bayesian inference\n\nYou can find out which engines can be used with the show_engines() function. The command show_engines(\"poisson_reg\") will give you the available engines for the poisson_reg() function.\nSo, we can create the model as follows:\n\nisl_mod <- poisson_reg() %>% \n  set_mode(\"regression\") %>% \n  set_engine(\"glm\")\n\nNote that we are not actually specifying any of the variables just yet! All we’ve done is tell R what kind of model we’re planning to use. If we want to see how parsnip converts this code to the package syntax, we can check this with translate():\n\nisl_mod %>% translate()\n\nPoisson Regression Model Specification (regression)\n\nComputational engine: glm \n\nModel fit template:\nstats::glm(formula = missing_arg(), data = missing_arg(), weights = missing_arg(), \n    family = stats::poisson)\n\n\nThis shows that we have a poisson regression model, where the outcome is going to be a regression. The model fit template tells us that we’ll be using the glm() function from the stats package, which can take a formula, data, weights and family argument. The family argument is already set to poisson.\nThe model fit template tells us that we’ll be using the glm() function from the stats package (stats::glm). This function has several arguments:\n\na formula, which we’ll specify later\n\ndata, which we’ll provide in a bit\n\nweights, if we want to add prior weights to our variable - we don’t have to concern ourselves with this - and\na family argument, which is already set to poisson\n\n\n\n\n\n\n\n\nThe family argument\n\n\n\nThe family argument gives us a description of the error distribution and link function that will be used in the model. For the islands data set we are looking at count outcome - which we can model using a poisson regression model.\nIf we’d want to specify it manually, then we’d use\nset_engine(\"glm\", family = stats::poisson(link = \"log\"))\nwhich sets the family to poisson, using a log link function.\n\n\nNow we’ve specified what kind of model we’re planning to use, we can fit our data to it, using the fit() function:\n\nisl_fit <- isl_mod %>% \n  fit(species ~ area,\n      data = islands)\n\nWe can look at the output directly, but I prefer to tidy the data up using the tidy() function from broom package:\n\nisl_fit %>% tidy()\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic   p.value\n  <chr>          <dbl>     <dbl>     <dbl>     <dbl>\n1 (Intercept)   4.24     0.0413      103.  0        \n2 area          0.0356   0.00125      28.6 2.73e-179\n\n\nThe output is strikingly similar to the binomial models (who’d have guessed, eh?) and the main numbers to extract from the output are the two numbers in the estimate column.\n\n\n\nThese are the coefficients of the Poisson model equation and need to be placed in the following formula in order to estimate the expected number of species as a function of island size:\n\\[ E(species) = \\exp(4.24 + 0.036 \\times area) \\]\nInterpreting this requires a bit of thought (not much, but a bit).\nThe intercept coefficient (\\(\\beta_0\\)), 4.24, is related to the number of species we would expect on an island of zero area (this is statistics, not real life. You’d do well to remember that before you worry too much about what that even means). But in order to turn this number into something meaningful we have to exponentiate it. Since \\(\\exp(4.24) \\approx 70\\), we can say that the baseline number of species the model expects on any island is 70. This isn’t actually the interesting bit though.\nThe coefficient of area (\\(\\beta_1\\)) is the fun bit. For starters we can see that it is a positive number which does mean that increasing area leads to increasing numbers of species. Good so far - since this matches what we saw when we plotted our data. But what does the value 0.036 actually mean?\nWell, if we exponentiate it too we get \\(\\exp(0.036) \\approx 1.04\\). This means that for every increase in area of 1 km2 (the original units of the area variable) the number of species on the island is multiplied by 1.04. So, an island of area 1 km2 is predicted to have \\(1.04 \\times 70 \\approx 72\\) species.\nSo, in order to interpret Poisson coefficients, you have to exponentiate them."
  },
  {
    "objectID": "materials/glm-practical-poisson.html#model-predictions",
    "href": "materials/glm-practical-poisson.html#model-predictions",
    "title": "\n9  Poisson regression\n",
    "section": "\n9.5 Model predictions",
    "text": "9.5 Model predictions\nNow that we can interpret the Poisson coefficients, it would be good to see if using a poisson regression to describe these data is actually a good idea.\nVisualisation is always useful, so in order to get an idea of how our data fits a Poisson regression, we’ll plot the Poisson regression curve. Next, we overlay our original data.\n\ntidyverse\n\n\nFirst, we create a table that contains data for the curve, starting for an area with value 1 to 50, in steps of 1.\n\nmodel <- tibble(area = seq(1, 50, 1))\n\nNext, we feed our model these data:\n\ncurve <- isl_fit %>% augment(new_data = model)\n\nThis gives the predicted number of species for each given value of area. If we have a closer look at these data we can see that, for example, for an area with a surface area of 4 km2 the predicted number of species is around 80. Nice.\n\nhead(curve)\n\n# A tibble: 6 × 2\n   area .pred\n  <dbl> <dbl>\n1     1  72.0\n2     2  74.6\n3     3  77.3\n4     4  80.1\n5     5  83.0\n6     6  86.0\n\n\nUsing these data, we can now plot all the predicted number of species and overlay our original measured data.\n\nggplot(curve, aes(area, .pred)) +\n  geom_line(colour = \"red\") +\n  geom_point(data = islands, aes(area, species))\n\n\n\n\n\n\n\nThat looks like a pretty decent fit, really. But of course we want to have a (slightly) less hand-wavy conclusion than that."
  },
  {
    "objectID": "materials/glm-practical-poisson.html#goodness-of-fit",
    "href": "materials/glm-practical-poisson.html#goodness-of-fit",
    "title": "\n9  Poisson regression\n",
    "section": "\n9.6 Goodness-of-fit",
    "text": "9.6 Goodness-of-fit\nWe can use the model’s residual deviance to assess how much the predicted values differ from the observed. This gives us an idea of how well-specified the model is. When a model is “true”, i.e. the model makes pretty accurate predictions, then we expect the residual deviance to be distributed as a \\(\\chi^2\\) random variable with degrees of freedom equal to the model’s residual degrees of freedom.\n\ntidyverse\n\n\nWe can get these parameters as follows and we’ll store them in a new object, so we can extract them in a bit.\n\nisl_fit %>% glance()\n\n# A tibble: 1 × 8\n  null.deviance df.null logLik   AIC   BIC deviance df.residual  nobs\n          <dbl>   <int>  <dbl> <dbl> <dbl>    <dbl>       <int> <int>\n1          857.      34  -139.  283.  286.     30.4          33    35\n\nisl_parameters <- isl_fit %>% glance()\n\nThe values we are interested in are in the deviance and df.residual columns, respectively.\nNext, we use the pchisq() function to calculate the correct probability.\n\npchisq(isl_parameters$deviance,\n       isl_parameters$df.residual,\n       lower.tail = FALSE)\n\n[1] 0.595347\n\n\nThis gives us a value of around 0.60. This suggests that this model is actually a pretty good one (if it wasn’t then the value would be close to zero) and that the data are pretty well supported by the model.\n\n\n\n\n\n\nImportant\n\n\n\nThe pchisq() function gives the lower tail probability that \\(\\chi^2 \\le x\\) by default. We’re actually interested in the probability that \\(\\chi^2 \\ge x\\). These two probabilities must sum to one, so we get the upper tail probability by setting the argument lower.tail = FALSE. An alternative way would be to use the default, but do 1 - pchisq().\n\n\nFor Poisson models this has an extra interpretation. This can be used to assess whether we have significant overdispersion in our data. For a Poisson model to be appropriate we need that the variance of the data to be exactly the same as the mean of the data. If there is overdispersion then the data would spread out more for higher predicted values of species than for lower ones. Our visualisation shows that this isn’t really happening. The spread is unlikely to be perfectly homogeneous, but we don’t want the data to spread out too much.\nThe easy way to check this is to look at the ratio of the residual deviance to the residual degrees of freedom (in this case 0.922). For a Poisson model to be valid, this ratio should be about 1. If the ratio is significantly bigger than 1 then we say that we have over-dispersion in the model and we wouldn’t be able to trust any of the significance testing using a Poisson regression."
  },
  {
    "objectID": "materials/glm-practical-poisson.html#confidence-intervals",
    "href": "materials/glm-practical-poisson.html#confidence-intervals",
    "title": "\n9  Poisson regression\n",
    "section": "\n9.7 Confidence intervals",
    "text": "9.7 Confidence intervals\nWe can also assess how reliable our model is by looking at the confidence intervals of the estimated parameters.\n\ntidyverse\n\n\nWe extracted the parameters of the model by using\n\nisl_fit %>% tidy()\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic   p.value\n  <chr>          <dbl>     <dbl>     <dbl>     <dbl>\n1 (Intercept)   4.24     0.0413      103.  0        \n2 area          0.0356   0.00125      28.6 2.73e-179\n\n\nAlthough we focussed on the estimate column, we can see that the associated standard errors for each estimate is also given in the std.error column. We can use these values to calculate the 95% confidence intervals.\nWe can either do this by hand through multiplying the standard errors by 1.96. We can then subtract from (giving the lower confidence estimate) or add to (giving the higher confidence estimate) the estimated parameter. This gives a pretty decent approximation.\nBut then again, life is short, so we can just use the additional argument that is available for the tidy() function. You can look at what columns are returned, but I’m selecting the relevant ones here:\n\nisl_fit %>% tidy(conf.int = TRUE,        # default is FALSE\n                 conf.level = 0.95) %>%  # is the default\n  select(term, estimate, conf.low, conf.high)\n\n# A tibble: 2 × 4\n  term        estimate conf.low conf.high\n  <chr>          <dbl>    <dbl>     <dbl>\n1 (Intercept)   4.24     4.16      4.32  \n2 area          0.0356   0.0332    0.0381\n\n\nWhat we’re interested in here is the confidence intervals for the area parameter. Before we delve into that, I’m also going to calculate the exponent for these confidence intervals. We can do this using the exp() function.\n\nisl_fit %>% tidy(conf.int = TRUE,        # default is FALSE\n                 conf.level = 0.95) %>%  # is the default\n  select(term, estimate, conf.low, conf.high) %>% \n  mutate(conf.low_exp = exp(conf.low),\n         conf.high_exp = exp(conf.high))\n\n# A tibble: 2 × 6\n  term        estimate conf.low conf.high conf.low_exp conf.high_exp\n  <chr>          <dbl>    <dbl>     <dbl>        <dbl>         <dbl>\n1 (Intercept)   4.24     4.16      4.32          64.1          75.3 \n2 area          0.0356   0.0332    0.0381         1.03          1.04\n\n\nThese values are a bit familiar, since we’ve previously determined based on the area coefficient that for each increase in square kilometer, the number of species increases by approximately 1.04.\nWhat these values tell us is that we can be 95% certain that for every increase in square kilometer of island area size, the number of species increases by a factor of somewhere between 1.034 and 1.039.\n\n\n\n\n\n\nNote\n\n\n\nIf there was no association between area and species, then the \\(\\beta_1\\) coefficient would be zero. That would mean that the exponent would be \\({e}^{\\beta_1}=1\\). The interval that we calculated for \\({e}^{\\beta_1}\\) lies between 1.034 and 1.039 and therefore does not include 1, so the model with area is preferred over the model without area.\nEquivalently, the interval for \\(\\beta_1\\) (0.033 - 0.038) does not include 0, again showing the significance of area as a predictor of species."
  },
  {
    "objectID": "materials/glm-practical-poisson.html#exercise-seatbelts",
    "href": "materials/glm-practical-poisson.html#exercise-seatbelts",
    "title": "\n9  Poisson regression\n",
    "section": "\n9.8 Exercise: Seatbelts",
    "text": "9.8 Exercise: Seatbelts\nI’d like you to do the following:\n\nLoad the data\nVisualise the data and create a poisson regression model\nPlot the regression model on top of the data\nAssess if the model is a decent predictor for the number of fatalities\n\n\n\n\n\n\n\nAnswer\n\n\n\n\n\n\n9.8.1 Load the data\nFirst, we load the data.\n\ntidyverse\n\n\n\nseatbelts <- read_csv(\"data/seatbelts.csv\")\n\nRows: 192 Columns: 10\n── Column specification ────────────────────────────────────────────────────────\nDelimiter: \",\"\nchr (1): month\ndbl (9): drivers_killed, drivers, front, rear, kms, petrol_price, van_killed...\n\nℹ Use `spec()` to retrieve the full column specification for this data.\nℹ Specify the column types or set `show_col_types = FALSE` to quiet this message.\n\n\n\n\n\n\n9.8.2 Visualise the data\nThe data tracks the number of drivers killed in road traffic accidents, before and after the seatbelt law was introduced. The information on whether the law was in place is encoded in the law column as 0 (law not in place) or 1 (law in place).\nThere are many more observations when the law was not in place, so we need to keep this in mind when we’re interpreting the data.\nFirst we have a look at the data comparing no law vs law:\n\ntidyverse\n\n\nWe have to convert the law column to a factor, otherwise R will see it as numerical.\n\nseatbelts %>% \n  ggplot(aes(as_factor(law), drivers_killed)) +\n   geom_boxplot()\n\n\n\n\nThe data are recorded by month and year, so we can also display the number of drivers killed by year:\n\nseatbelts %>% \n  ggplot(aes(year, drivers_killed)) +\n  geom_point()\n\n\n\n\n\n\n\nThe data look a bit weird. There is quite some variation within years (keeping in mind that the data are aggregated monthly). The data also seems to wave around a bit… with some vague peaks (e.g. 1972 - 1973) and some troughs (e.g. around 1976).\nSo my initial thought is that these data are going to be a bit tricky to interpret. But that’s OK.\n\n9.8.3 Model building\nWe’re dealing with count data, so we’re going to use a poisson regression.\n\ntidyverse\n\n\nAs before, we first define the model type.\n\nstb_mod <- poisson_reg() %>% \n  set_mode(\"regression\") %>% \n  set_engine(\"glm\")\n\nAnd check that everything is in order.\n\nstb_mod %>% translate()\n\nPoisson Regression Model Specification (regression)\n\nComputational engine: glm \n\nModel fit template:\nstats::glm(formula = missing_arg(), data = missing_arg(), weights = missing_arg(), \n    family = stats::poisson)\n\n\nNext, we fit our data to the model we just specified:\n\nstb_fit <- stb_mod %>% \n  fit(drivers_killed ~ year,\n      data = seatbelts)\n\nAnd we can extract the estimated coefficients from these fitted data:\n\nstb_fit %>% tidy()\n\n# A tibble: 2 × 5\n  term        estimate std.error statistic  p.value\n  <chr>          <dbl>     <dbl>     <dbl>    <dbl>\n1 (Intercept)  37.2      2.80         13.3 2.62e-40\n2 year         -0.0164   0.00142     -11.6 5.88e-31\n\n\n\n\n\n\n9.8.4 Visualise the model\nTo see if the model is actually a decent prediction for our data, we can plot it.\n\ntidyverse\n\n\nTo do this, we create modelled values for our predictor variable year. Because we have monthly data, we create a sequence of “years” in 1/12th intervals - one for each month.\nNext, we ask the model to predict the number of drivers killed based on these values.\nLastly, we can plot those predicted values against the observed values in our data set.\n\n# create the sequence of values that are used\n# in predicting number of deaths\nmodel <- tibble(year = seq(1969, 1984, (1/12)))\n\n# fit these data to the model\nstb_curve <- stb_fit %>% augment(new_data = model)\n\n# plot the predicted values\n# and overlay the observed values\nggplot(seatbelts, aes(year, drivers_killed)) +\n  geom_point() +\n  geom_point(data = stb_curve, aes(x = year, y = .pred),\n             colour = \"red\")\n\n\n\n\n\n\n\nThat does not look like a very good fit, but then again the data look rather messy as well.\n\n9.8.5 Goodness-of-fit\nLet’s check the goodness-of-fit.\n\ntidyverse\n\n\nFirst we store the parameter estimates in an object. Then we use the pchisq() function to calculate the probability that the residual deviance is actually distributed as a \\(\\chi^2\\) random variable with degrees of freedom equal to the model’s residual degrees of freedom.\nYes, you can read that sentence three times and still wonder what that really means. Suffice to say is that the outcome gives us a measure of how well-specified the model is.\n\nstb_parameter <- stb_fit %>% glance()\n\nstb_parameter\n\n# A tibble: 1 × 8\n  null.deviance df.null logLik   AIC   BIC deviance df.residual  nobs\n          <dbl>   <int>  <dbl> <dbl> <dbl>    <dbl>       <int> <int>\n1          984.     191 -1062. 2127. 2134.     850.         190   192\n\npchisq(stb_parameter$deviance,\n       stb_parameter$df.residual,\n       lower.tail = FALSE)\n\n[1] 3.12987e-84\n\n\n\n\n\nWell, that’s a bit of a blow. The probability value is extremely low, suggesting that the model is not very well-specified. Which kind of matches what we already saw in the plot. It might still be better than the null model (“the data can be modelled as the average across all the observations”), but we seem to be missing some parameters here.\n\n9.8.6 Confidence intervals\nSimilar to the islands example, we can also calculate the confidence intervals associated with our estimated parameters.\n\ntidyverse\n\n\n\nstb_fit %>% tidy(conf.int = TRUE,        # default is FALSE\n                 conf.level = 0.95) %>%  # is the default\n  select(term, estimate, conf.low, conf.high) %>% \n  mutate(conf.low_exp = exp(conf.low),\n         conf.high_exp = exp(conf.high))\n\n# A tibble: 2 × 6\n  term        estimate conf.low conf.high conf.low_exp conf.high_exp\n  <chr>          <dbl>    <dbl>     <dbl>        <dbl>         <dbl>\n1 (Intercept)  37.2     31.7      42.7        5.78e+13      3.34e+18\n2 year         -0.0164  -0.0191   -0.0136     9.81e- 1      9.86e- 1\n\n\nWe’re interested in the confidence interval for the year variable. Remember that if there is no association at all between year and drivers_killed then the parameter \\(e^{\\beta_1} = 1\\).\nIn our case the interval we calculated for \\(e^{\\beta_1}\\) lies between 0.981 and 0.986. This does not include 1, so it seems that the model that takes year into account is still preferred over a model that doesn’t."
  },
  {
    "objectID": "materials/glm-practical-poisson.html#key-points",
    "href": "materials/glm-practical-poisson.html#key-points",
    "title": "\n9  Poisson regression\n",
    "section": "\n9.9 Key points",
    "text": "9.9 Key points\n\n\n\n\n\n\nNote\n\n\n\n\nPoisson regression is useful when dealing with count data"
  }
]