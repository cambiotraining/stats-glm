{
  "hash": "40f8f1fb2d67cd27aa235682242a58a4",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Overdispersion\"\n---\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-tip}\n## Learning outcomes\n\n**Questions**\n\n- What is overdispersion and why is it important?\n- How do we deal with overdispersion?\n\n**Objectives**\n\n- Be able to recognise overdispersion.\n- Be able to perform a negative binomial regression on count data.\n- Understand the difference between it and Poisson regression.\n- Evaluate and interpret suitability of the model.\n\n:::\n\n## Libraries and functions\n\n::: {.callout-note collapse=\"true\"}\n## Click to expand\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n### Libraries\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MASS)\nlibrary(performance)\n```\n:::\n\n\n### Functions\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# fits a negative binomial model\nMASS::glm.nb()\n\n# checks for overdispersion\nperformance::check_overdispersion()\n```\n:::\n\n\n\n## Python\n\n### Libraries\n\n\n::: {.cell}\n\n```{.python .cell-code}\n# A maths library\nimport math\n# A Python data analysis and manipulation tool\nimport pandas as pd\n\n# Python equivalent of `ggplot2`\nfrom plotnine import *\n\n# Statistical models, conducting tests and statistical data exploration\nimport statsmodels.api as sm\n\n# Convenience interface for specifying models using formula strings and DataFrames\nimport statsmodels.formula.api as smf\n\n# Needed for additional probability functionality\nfrom scipy.stats import *\n```\n:::\n\n\n### Functions\n\n:::\n:::\n\nIn the previous chapter we looked at how to analyse count data. We used a Poisson regression to do this. A key assumption in a Poisson regression is that the mean of the count data is equal to the variance.\n\nThat's great - until the observed variance isn't equal to the mean. If, instead, the observed variance in your data exceeds the mean of the counts we have **overdispersion**. Similarly, if it's lower we have **underdispersion**.\n\nQueue negative binomial models.\n\nNegative binomial models are also used for count data, but these models don’t require that the variance of the data exactly matches the mean of the data, and so they can be used in situations where your data exhibit overdispersion.\n\nWe'll explore this with the `galapagos` example. You can find the data in:\n\n`data/galapagos.csv`\n\nThere are 30 Galapagos islands and 4 variables in the data. The relationship between the number of plant species (`species`) and several geographic variables is of interest.\n\n* `endemics` – the number of endemic species\n* `area` – the area of the island km<sup>2</sup>\n* `elevation` – the highest elevation of the island (m).\n* `nearest` – the distance from the nearest island (km)\n\n## Load and visualise the data\n\nFirst we load the data, then we visualise it.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngalapagos <- read_csv(\"data/galapagos.csv\")\n```\n:::\n\n\nLet's have a glimpse at the data:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngalapagos\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 30 × 5\n   species endemics  area elevation nearest\n     <dbl>    <dbl> <dbl>     <dbl>   <dbl>\n 1      58       23 25.1        346     0.6\n 2      31       21  1.24       109     0.6\n 3       3        3  0.21       114     2.8\n 4      25        9  0.1         46     1.9\n 5       2        1  0.05        77     1.9\n 6      18       11  0.34       119     8  \n 7      24        0  0.08        93     6  \n 8      10        7  2.33       168    34.1\n 9       8        4  0.03        71     0.4\n10       2        2  0.18       112     2.6\n# ℹ 20 more rows\n```\n\n\n:::\n:::\n\n\n\n## Python\n\n\n::: {.cell}\n\n```{.python .cell-code}\ngalapagos_py = pd.read_csv(\"data/galapagos.csv\")\n```\n:::\n\n\nLet's have a glimpse at the data:\n\n\n::: {.cell}\n\n```{.python .cell-code}\ngalapagos_py.head()\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n   species  endemics   area  elevation  nearest\n0       58        23  25.09        346      0.6\n1       31        21   1.24        109      0.6\n2        3         3   0.21        114      2.8\n3       25         9   0.10         46      1.9\n4        2         1   0.05         77      1.9\n```\n\n\n:::\n:::\n\n\n:::\n\nWe can plot the data:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngalapagos %>% \n  pairs(lower.panel = NULL)\n```\n\n::: {.cell-output-display}\n![](glm-practical-negative_binomial_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\n## Python\n:::\n\nIt looks as though `endemics` and `elevation` might be related to `species`, but\n`area` and `nearest` are harder to work out.\n\nGiven that the response variable, `species`, is a count variable we try to construct a Poisson regression. We decide that there is no biological reason to look for interaction between the various predictor variables and so we don’t construct a model with any interactions. Remember that this may or may not be a sensible thing to do in general.\n\n## Constructing a model\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nglm_gal <- glm(species ~ area + endemics + elevation + nearest,\n               data = galapagos, family = \"poisson\")\n```\n:::\n\n\nand we look at the model summary:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(glm_gal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm(formula = species ~ area + endemics + elevation + nearest, \n    family = \"poisson\", data = galapagos)\n\nCoefficients:\n              Estimate Std. Error z value Pr(>|z|)    \n(Intercept)  2.794e+00  5.332e-02  52.399  < 2e-16 ***\narea        -1.266e-04  2.559e-05  -4.947 7.53e-07 ***\nendemics     3.325e-02  9.164e-04  36.283  < 2e-16 ***\nelevation    3.799e-04  9.432e-05   4.028 5.63e-05 ***\nnearest      9.049e-03  1.327e-03   6.819 9.18e-12 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for poisson family taken to be 1)\n\n    Null deviance: 3510.73  on 29  degrees of freedom\nResidual deviance:  315.88  on 25  degrees of freedom\nAIC: 486.71\n\nNumber of Fisher Scoring iterations: 5\n```\n\n\n:::\n:::\n\n\n## Python\n\n:::\n\nNow, this time, before we start looking at interpreting the model coefficients were going to jump straight into assessing whether the model is well-specified (spoiler alert: we do this because I already know that it isn't...).\n\nWe can formally check this with our trusty \"Is the model well-posed\" probability value:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 - pchisq(315.88, 25)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n## Python\n:::\n\nThis gives a big fat 0, so no, there are definitely things wrong with our model and we can’t really trust anything that’s being spat out at this stage. The issue in this case lies with overdispersion.\n\n::: {.callout-note}\n## Dispersion parameter\nOne way of assessing dispersion is by calculating the dispersion parameter, $\\theta$. This takes the residual deviance and divides it by the number of degrees of freedom.\n\nThe residual deviance is 315.88, but we only have 25 degrees of freedom in the model. The number of degrees of freedom are low because we only have 30 data points but have 4 parameters in our model, leading to $30 - 4 - 1 = 25$ degrees of freedom. So we have:\n\n$$\\theta = 315.88 / 25 = 12.64$$\n\nThe Poisson regression is *assuming* the value is 1. But the actual $\\theta$ is nowhere near close to 1, so that's is a bad idea.\n:::\n\n::: {.callout-note collapse=\"true\"}\n## Other methods to calculate $\\theta$\n\nIt wouldn't be statistics if there weren't multiple ways to assess the same thing! \n\n::: {.panel-tabset group=\"language\"}\n## R\n\nWe can use the `check_overdispersion()` function from the `performance` package. If we do this on our `glm_gal` model, we get the following:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncheck_overdispersion(glm_gal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# Overdispersion test\n\n       dispersion ratio =  11.910\n  Pearson's Chi-Squared = 297.747\n                p-value = < 0.001\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nOverdispersion detected.\n```\n\n\n:::\n:::\n\n\nYou'll notice that the dispersion parameter is slightly different from the one we calculated. That's because it uses a slightly different method (see `?check_overdispersion` if you're *really* interested). It is, however, a nice quick-and-easy function to assess overdispersion.\n\n## Python\n:::\n:::\n\n\nSo, with that conclusion, we won’t bother looking at the analysis of deviance table or asking whether the model is better than the null model. Instead we need to find a better fitting model...\n\nFor count response data options are limited, but the main alternative to a Poisson model is something called a negative binomial model. \n\n## Negative binomial model\n\n::: {.panel-tabset group=\"language\"}\n## R\n\nTo specify a negative binomial model, we use the `MASS` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(MASS)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_gal <- glm.nb(species ~ area + endemics + elevation + nearest,\n               data = galapagos)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(nb_gal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm.nb(formula = species ~ area + endemics + elevation + nearest, \n    data = galapagos, init.theta = 2.987830946, link = log)\n\nCoefficients:\n              Estimate Std. Error z value Pr(>|z|)    \n(Intercept)  2.4870922  0.1864426  13.340  < 2e-16 ***\narea        -0.0002911  0.0001941  -1.500    0.134    \nendemics     0.0457287  0.0065890   6.940 3.92e-12 ***\nelevation    0.0003053  0.0005137   0.594    0.552    \nnearest      0.0040316  0.0079105   0.510    0.610    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for Negative Binomial(2.9878) family taken to be 1)\n\n    Null deviance: 151.446  on 29  degrees of freedom\nResidual deviance:  33.395  on 25  degrees of freedom\nAIC: 286.06\n\nNumber of Fisher Scoring iterations: 1\n\n              Theta:  2.988 \n          Std. Err.:  0.898 \n\n 2 x log-likelihood:  -274.060 \n```\n\n\n:::\n:::\n\n\nThis output is very similar to the other GLM outputs that we’ve seen but with some additional information at the bottom regarding the dispersion parameter that the negative binomial model has used, which it calls Theta (2.988). It is estimated from the data.\n\nAs before, the main numbers to extract from the output are the numbers underneath `Estimate` in the `Coefficients` table:\n\n```\nCoefficients:\n              Estimate\n(Intercept)  2.4870922\narea        -0.0002911\nendemics     0.0457287\nelevation    0.0003053\nnearest      0.0040316\n```\n\n## Python\n\n:::\n\nThese are the coefficients of the Negative Binomial model equation and need to be placed in the following formula in order to estimate the expected number of species as a function of the other variables.:\n\n$$\n\\begin{split}\n  E(species) = \\exp(2.49 - 0.0003 \\times area + 0.046 \\times endemics\\\\\n  + \\ 0.0003 \\times elevation + 0.004 \\times nearest)\n\\end{split}\n$$\n\n::: {.callout-important}\n## Key concept\n\nThe main difference between a Poisson regression and a negative binomial regression: in the former the dispersion parameter is assumed to be 1, whereas in the latter it is estimated from the data.\n\nAs such, the negative binomial model has the same form for its line of best fit as the Poisson model, but the underlying probability distribution is different.\n:::\n\n### Assessing significance\n\nWe can ask the same three questions we asked before.\n\n1. Is the model well-specified?\n2. Is the overall model better than the null model?\n3. Are any of the individual predictors significant?\n\nTo assess whether the model is any good we’ll use the residual deviance and the residual degrees of freedom.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 - pchisq(33.395, 25)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1214851\n```\n\n\n:::\n:::\n\n\nInstead of manually typing in the values, which is of course prone to errors, we can also extract them directly from the model object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 - pchisq(nb_gal$deviance, nb_gal$df.residual)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.1214756\n```\n\n\n:::\n:::\n\n\n## Python\n:::\n\nThis gives a probability of 0.121. Whilst this isn’t brilliant, it is still much better than the model we had before, and now that we’ve taken account of the overdispersion issue, the fact that this probability is a bit small is probably down to the fact that the predictor variables we have in the model might not be enough to fully explain the number of `species` on each of the Galapagos islands. \n\nHowever, since we don’t have any other data to play with there’s nothing we can do about that right now.\n\nTo assess if the overall model, with all four terms, is better than the null model we’ll look at the difference in deviances and the difference in degrees of freedom:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 - pchisq(151.446 - 33.395, 29 - 25)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\nOr extracting them directly from the model object:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 - pchisq(nb_gal$null.deviance - nb_gal$deviance,\n           nb_gal$df.null - nb_gal$df.residual)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0\n```\n\n\n:::\n:::\n\n\n## Python\n:::\n\nThis gives a reported p-value of 0, which is pretty darn small. So, yes, this model is better than nothing at all and at least some of our predictors are related to the response variable in a meaningful fashion.\n\nFinally, we’ll construct an analysis of deviance table to look at the individual predictors:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nanova(nb_gal, test = \"Chisq\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in anova.negbin(nb_gal, test = \"Chisq\"): tests made without\nre-estimating 'theta'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: glm.fit: algorithm did not converge\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Deviance Table\n\nModel: Negative Binomial(2.9878), link: log\n\nResponse: species\n\nTerms added sequentially (first to last)\n\n          Df Deviance Resid. Df Resid. Dev  Pr(>Chi)    \nNULL                         29    151.446              \narea       1   33.873        28    117.574 5.884e-09 ***\nendemics   1   83.453        27     34.121 < 2.2e-16 ***\nelevation  1    0.468        26     33.653    0.4939    \nnearest    1    0.257        25     33.395    0.6121    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\nYou might get a warning message about theta not being recalculated but this isn’t something to worry about.\n\n## Python\n:::\n\nFor more detail on the deviance table, refer to the chapter on [Significance testing & goodness-of-fit](significance-testing.qmd).\n\nWe can now see that it looks like two of our predictor variables aren’t actually significant predictors at all, and that only the `area` and number of endemic species (`endemics`) on each island is a significant predictor of the number of plant species on each Galapagos island. We can check this further using backward stepwise elimination.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstep(nb_gal)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\nStart:  AIC=284.06\nspecies ~ area + endemics + elevation + nearest\n\n            Df Deviance    AIC\n- nearest    1   33.653 282.32\n- elevation  1   33.831 282.50\n<none>           33.395 284.06\n- area       1   35.543 284.21\n- endemics   1   70.764 319.43\n\nStep:  AIC=282.32\nspecies ~ area + endemics + elevation\n\n            Df Deviance    AIC\n- elevation  1   33.814 280.78\n<none>           33.351 282.32\n- area       1   35.795 282.76\n- endemics   1   70.183 317.15\n\nStep:  AIC=280.77\nspecies ~ area + endemics\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: glm.fit: algorithm did not converge\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n           Df Deviance    AIC\n- area      1   35.179 280.72\n<none>          33.232 280.77\n- endemics  1  114.180 359.72\n\nStep:  AIC=280.66\nspecies ~ endemics\n\n           Df Deviance    AIC\n<none>          33.204 280.66\n- endemics  1  137.826 383.28\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:  glm.nb(formula = species ~ endemics, data = galapagos, init.theta = 2.695721184, \n    link = log)\n\nCoefficients:\n(Intercept)     endemics  \n    2.63124      0.04378  \n\nDegrees of Freedom: 29 Total (i.e. Null);  28 Residual\nNull Deviance:\t    137.8 \nResidual Deviance: 33.2 \tAIC: 282.7\n```\n\n\n:::\n:::\n\n\n## Python\n:::\n\nThis shows that only `endemics` is an appropriate predictor. See the Core statistics notes on [Backwards stepwise elimination](https://cambiotraining.github.io/corestats/materials/cs5_practical_model-comparisons.html#backwards-stepwise-elimination) for more information.\n\n::: {.callout-note}\n## Spot the difference\n\nThis minimal model is a bit surprising, because in the analysis of deviance table output the `area` variable was also highly significant. As such, we would have expected this variable to be retained during the BSE.\n\nThis is partly to do with the *order* in which the different terms are tested. In the analysis of deviance table there is a hint: `Terms added sequentially (first to last)`. Our model is `species ~ area + endemics + elevation + nearest` and when the individual p-values are calculated, it makes comparisons between the different terms in a sequential order. Or, `species ~ area + endemics + ...` will not give the same results as `species ~ endemics + area + ...`. We can check this:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nm1 <- glm.nb(species ~ endemics + area + elevation + nearest, data = galapagos)\n\nanova(m1, test = \"Chisq\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning in anova.negbin(m1, test = \"Chisq\"): tests made without re-estimating\n'theta'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stdout}\n\n```\nAnalysis of Deviance Table\n\nModel: Negative Binomial(2.9878), link: log\n\nResponse: species\n\nTerms added sequentially (first to last)\n\n          Df Deviance Resid. Df Resid. Dev Pr(>Chi)    \nNULL                         29    151.446             \nendemics   1  115.325        28     36.122   <2e-16 ***\narea       1    2.001        27     34.121   0.1572    \nelevation  1    0.468        26     33.653   0.4939    \nnearest    1    0.257        25     33.395   0.6121    \n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n```\n\n\n:::\n:::\n\n\n## Python\n:::\n\nIf we order the predictor variables like this, the `area` variable no longer comes back as statistically significant.\n\nIn the [significance testing](significance-testing.qmd) section we go through this in more detail and show you how you can make individual comparisons.\n:::\n\nOur new best model only contains `endemics` as a predictor, so we should fit this model and check that it still is an adequate model.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nnb_gal_min <- glm.nb(species ~ endemics, data = galapagos)\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary(nb_gal_min)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n\nCall:\nglm.nb(formula = species ~ endemics, data = galapagos, init.theta = 2.695721175, \n    link = log)\n\nCoefficients:\n            Estimate Std. Error z value Pr(>|z|)    \n(Intercept) 2.631244   0.164242   16.02   <2e-16 ***\nendemics    0.043785   0.004233   10.34   <2e-16 ***\n---\nSignif. codes:  0 '***' 0.001 '**' 0.01 '*' 0.05 '.' 0.1 ' ' 1\n\n(Dispersion parameter for Negative Binomial(2.6957) family taken to be 1)\n\n    Null deviance: 137.826  on 29  degrees of freedom\nResidual deviance:  33.204  on 28  degrees of freedom\nAIC: 282.66\n\nNumber of Fisher Scoring iterations: 1\n\n              Theta:  2.696 \n          Std. Err.:  0.789 \n\n 2 x log-likelihood:  -276.662 \n```\n\n\n:::\n:::\n\n\nIf we look at the deviance residuals (33.204) and the residual degrees of freedom (28), we can use the `pchisq()` function to get an overall assessment of whether this model is well-specified.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n1 - pchisq(nb_gal_min$deviance, nb_gal_min$df.residual)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n[1] 0.2283267\n```\n\n\n:::\n:::\n\n\nAnd we get a probability of 0.228 which is better than before, not amazing, but it might be adequate for what we have. Woohoo!\n\n## Python\n:::\n\nThe model equation for a negative binomial curve is the same as for a Poisson\nmodel and so, lifting the coefficients from the summary output we have the following relationship in our model:\n\n$$E(species) = \\exp(2.63 + 0.044 \\times endemics)$$\n\n### Model suitability\n\nAs we saw above, the model we created was not terribly well-specified. We can visualise it as follows:\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(galapagos, aes(endemics, species)) +\n  geom_point() +\n  geom_smooth(method = \"glm.nb\", se = FALSE, fullrange = TRUE)\n```\n\n::: {.cell-output-display}\n![](glm-practical-negative_binomial_files/figure-html/unnamed-chunk-28-1.png){width=672}\n:::\n:::\n\n\n## Python\n:::\n\nWe can see that at the lower range of `endemics`, the model is predicting values that are a bit too high. In the mid-range it predicts values that are too low and at the higher end the model is, well, rubbish.\n\nLet's compare it directly to our original Poisson regression (setting the limits of the y-axes to match):\n\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n::: {.cell-output-display}\n![Comparing Poisson and negative binomial regression](glm-practical-negative_binomial_files/figure-html/fig-poisson_vs_nb-1.png){#fig-poisson_vs_nb width=672}\n:::\n:::\n\n\n::: {.callout-note collapse=\"true\"}\n## Show code\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\np1 <- ggplot(galapagos, aes(endemics, species)) +\n  geom_point() +\n  geom_smooth(method = \"glm\", se = FALSE, fullrange = TRUE,\n              method.args = list(family = poisson)) +\n  ylim(0, 500) +\n  labs(title = \"Poisson\")\n\np2 <- ggplot(galapagos, aes(endemics, species)) +\n  geom_point() +\n  geom_smooth(method = \"glm.nb\", se = FALSE, fullrange = TRUE) +\n  ylim(0, 500) +\n  labs(title = \"Negative binomial\")\n```\n:::\n\n\n## Python\n:::\n:::\n\nSo, @fig-poisson_vs_nb shows that, although we've dealt with the overdispersion we had in the original Poisson regression, we still have a pretty poor fitting model. So, what is a sad researcher to do? We'll let you explore this in an exercise.\n\n:::{.callout-important}\nComplete [Exercise -@sec-exr_galapagos].\n:::\n\n## Exercises\n\n### Galapagos models {#sec-exr_galapagos}\n\n:::{.callout-exercise}\n\n\n{{< level 2 >}}\n\n\n\nFor this exercise we'll be using the data from `data/galapagos.csv`.\n\nThe fit for both the Poisson and Negative binomial regressions is not very good, suggesting that the model is not well-specified. How could we improve this?\n\n::: {.callout-answer collapse=\"true\"}\n\nThere appears to be a power relationship between `species` and `endemics`. So, one thing we could do is log-transform the response (`species`) and predictor (`endemics`) variables.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(data = galapagos,\n       aes(x = log(endemics),\n           y = log(species))) +\n  geom_point()\n```\n\n::: {.cell-output-display}\n![](glm-practical-negative_binomial_files/figure-html/unnamed-chunk-32-1.png){width=672}\n:::\n:::\n\n\n\n## Python\n:::\n\nWe could add a regression line to this. Additionally, we could just log-transform `endemics` and fit a negative binomial model to this. Let's do all of this and plot them together with the original Poisson and Negative binomial models.\n\n::: {.panel-tabset group=\"language\"}\n## R\n\n\n::: {.cell}\n\n```{.r .cell-code}\np3 <- ggplot(galapagos, aes(log(endemics), log(species))) +\n  geom_point() +\n  geom_smooth(method = \"lm\", se = FALSE, fullrange = TRUE,\n              method.args = list(family = poisson)) +\n  labs(title = \"Linear model of log-log\")\n\n\np4 <- ggplot(galapagos, aes(log(endemics), species)) +\n  geom_point() +\n  geom_smooth(method = \"glm.nb\", se = FALSE, fullrange = TRUE) +\n  ylim(0, 500) +\n  labs(title = \"Negative binomial of log(endemics)\")\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\np1 + p2 + p3 + p4 +\n  plot_annotation(tag_levels = \"A\")\n```\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 11 rows containing missing values or values outside the scale range\n(`geom_smooth()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 1 row containing non-finite outside the scale range\n(`stat_smooth()`).\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: In lm.wfit(x, y, w, offset = offset, singular.ok = singular.ok, \n    ...) :\n extra argument 'family' will be disregarded\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\n`geom_smooth()` using formula = 'y ~ x'\n```\n\n\n:::\n\n::: {.cell-output .cell-output-stderr}\n\n```\nWarning: Removed 1 row containing non-finite outside the scale range\n(`stat_smooth()`).\n```\n\n\n:::\n\n::: {.cell-output-display}\n![](glm-practical-negative_binomial_files/figure-html/unnamed-chunk-34-1.png){width=672}\n:::\n:::\n\n\n## Python\n\n:::\n\nFrom this it is clear that the negative binomial model fitted to `species ~ log(endemics)` in panel D produces a much better fit than the original fit in panel B.\n\nEqually, looking at the relationship between `log(species) ~ log(endemics)` in panel C it illustrates that this is pretty well-modelled using a linear line.\n\nThere is a slight issue though. If you look carefully then you see that in both panels C and D there is a stray value left of zero. There is also a warning message, saying `Removed 1 row containing non-finite outside the scale range`. If you'd look at the data, you'd notice that there is one island where the number of `endemics` is equal to 0. If we take the `log(0)` we get minus infinity. Which has little biological relevance, of course.\n\nWe could adjust for this by adding a \"pseudo-count\", or adding `1` to all of the counts. If that is acceptable or not is a matter of debate and I'll leave it to you to ponder over this. I would say that, whatever you do, make sure that you are transparent and clear on what you are doing and what the justification for it it.\n\n:::\n:::\n\n## Summary\n\n::: {.callout-tip}\n#### Key points\n\n- Negative binomial regression relaxes the assumption made by Poisson regressions that the variance is equal to the mean.\n- In a negative binomial regression the dispersion parameter $\\theta$ is estimated from the data, whereas in a regular Poisson regression it is assumed to be $1$.\n:::\n",
    "supporting": [
      "glm-practical-negative_binomial_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}