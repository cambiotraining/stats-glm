---
title: "Generalising your model"
---
```{r}
#| echo: false
#| message: false
#| results: hide
source(file = "setup_files/setup.R")
```

```{python}
#| echo: false
#| message: false
import shutup;shutup.please()
exec(open('setup_files/setup.py').read())
```

```{r}
#| echo: false
#| message: false

# required data sets
finches <- read_csv("data/finch_beaks.csv")

fortis_1975 <- finches %>% filter(species == "fortis", year == 1975)
```

## Putting the "G" into "GLM"

In the previous linear model example all the assumptions were met. But what if we have data where that isn't the case? For example, what if we have data where we _can't_ describe the relationship between the predictor and response variables in a linear way?

One of the ways we can deal with this is by using a **generalised linear model**, also abbreviated as GLM. In a way it's an extension of the linear model we discussed in the previous section. As with the normal linear model, the predictor variables in the model are in a linear combination, such as:

$$
\beta_0 + \beta_1X_1 + \beta_2X_2 + \beta_3X_3 + ...
$$

Here, the $\beta_0$ value is the constant or intercept, whereas each subsequent $\beta_i$ is a unique regression coefficient for each $X_i$ predictor variable. So far so good.

However, the GLM makes the linear model more flexible in two ways:

:::.{callout-important}
1. In a standard linear model the linear combination (e.g. like we see above) becomes the predicted outcome value. With a GLM a transformation is specified, which turns the linear combination into the predicted outcome value. This is called a **link function**.
2. A standard linear model assumes a continuous, normally distributed outcome, whereas **with GLM the outcome can be both continuous or integer**. Furthermore, the outcome does not have to be normally distributed. Indeed, **the outcome can follow a different kind of distribution**, such as binomial, Poisson, exponential etc.
:::

We'll introduce each of these elements below, then illustrate how they are used in practice, using different types of data.

The link function and different distributions are closely...err, _linked_. So in order to make sense of what the link function is doing, it's useful to understand better the different distributional assumptions. So we'll start with those.

## Distributions

In the examples of a linear model we've seen that the residuals needed to be normally distributed. We've mainly used the Q-Q plot to assess this assumption of normality.

But what does "normal" actually mean? It assumes that the residuals are coming from a normal or Gaussian distribution. This distribution has a symmetrical bell-shape, where the centre is the mean, and half of the data are on either side of this.

We can see this in @fig-normdist. The mean of the normal distribution is indicated with the dashed blue line.

```{r}
#| echo: false
mean_resid <- fortis_1975 %>% 
  lm(bdepth ~ blength, data = .) %>%
  resid() %>%
  as_tibble() %>%
  summarise(mean = mean(value)) %>% 
  pull()

sd_resid <- fortis_1975 %>% 
  lm(bdepth ~ blength, data = .) %>%
  resid() %>%
  as_tibble() %>%
  summarise(sd = sd(value)) %>% 
  pull()
```

```{r}
#| echo: false
p1 <- fortis_1975 %>% 
  lm(bdepth ~ blength, data = .) %>%
  resid() %>%
  as_tibble() %>%
  #rstatix::get_summary_stats()
  ggplot(aes(x = value)) +
  stat_dist_halfeye(aes(dist = dist_normal(mean_resid, sd_resid)),
                    orientation = "horizontal") +
  geom_vline(xintercept = mean_resid, colour = "blue", linetype = "dashed") +
  labs(title = "A normal distribution",
       subtitle = "with mean indicated",
       x = NULL,
       y = "probability")
```

```{r}
#| echo: false
p2 <- fortis_1975 %>% 
  lm(bdepth ~ blength, data = .) %>%
  resid() %>%
  as_tibble() %>%
  #rstatix::get_summary_stats()
  ggplot(aes(x = value)) +
  stat_dist_halfeye(aes(dist = dist_normal(mean_resid, sd_resid)),
                    orientation = "horizontal") +
 stat_dotsinterval(aes(x = value),
                    orientation = "horizontal",
                    fill = "firebrick", scale = 1) +
  geom_vline(xintercept = mean_resid, colour = "blue", linetype = "dashed") +
  labs(title = "G. fortis (1975)",
       subtitle = "residuals and normal distribution",
       x = NULL,
       y = "probability")
```

```{r}
#| echo: false
#| label: fig-normdist
#| fig-cap: "Normal distribution"
p1 / p2 +
  plot_annotation(tag_levels = "A")
```

We can use the linear model we created previously, where we looked at the possible linear relationship between beak length and beak length. This is based on measurements of _G. fortis_ beaks in 1975.

The individual values of the residuals from this linear model are shown in @fig-normdist, panel B (in red), with the corresponding theoretical normal distribution in the background. We can see that the residuals follow this distribution reasonably well, which matches our conclusions from the Q-Q plot (see @fig-fortis1975_lm_dgplots).

All this means is that assuming that these residuals may come from a normal distribution isn't such a daft suggestion after all.

Now look at this example:

```{r}
#| echo: false
#| message: false
finches_2020 <- read_csv("data/41559_2020_1183_MOESM2_ESM.csv")
finches_2020 <- finches_2020 %>% 
  clean_names() %>% 
  mutate(timepoint = (str_detect(group, "Late")),
         timepoint = if_else(timepoint == FALSE, "early", "late"),
         timepoint = factor(timepoint))

early_finches <- finches_2020 %>% 
  filter(timepoint == "early") %>% 
  mutate(pointed_beak = if_else(str_detect(group, "blunt"), 0, 1))
```

```{r}
#| echo: false
p3 <- ggplot(early_finches,
       aes(x = blength, y = as.character(pointed_beak))) +
  geom_point() +
  labs(x = "beak length (mm)",
       y = "class") +
  scale_y_discrete(labels = c("blunt", "pointed"))
```


```{r}
#| echo: false
lm_early <- lm(pointed_beak ~ bdepth,
   data = early_finches)

mean_resid_early <- lm_early %>% 
  resid() %>%
  as_tibble() %>%
  summarise(mean = mean(value)) %>% 
  pull()

sd_resid_early <- lm_early %>% 
  resid() %>%
  as_tibble() %>%
  summarise(sd = sd(value)) %>% 
  pull()

p4 <- lm_early %>% 
  resid() %>%
  as_tibble() %>%
  #rstatix::get_summary_stats()
  ggplot(aes(x = value)) +
  stat_dist_halfeye(aes(dist = dist_normal(mean_resid_early,
                                           sd_resid_early)),
                    orientation = "horizontal") +
  stat_dotsinterval(aes(x = value),
                    orientation = "horizontal",
                    fill = "firebrick", scale = 1) +
  geom_vline(xintercept = mean_resid_early,
             colour = "blue", linetype = "dashed") +
  labs(title = "default residuals",
       x = NULL,
       y = "probability")
```


```{r}
#| echo: false
glm_early <- glm(pointed_beak ~ blength,
                 family = binomial(link = "logit"),
                 data = early_finches)

mean_resid_early_glm <- glm_early %>% 
  resid() %>%
  as_tibble() %>%
  summarise(mean = mean(value)) %>% 
  pull()

sd_resid_early_glm <- glm_early %>% 
  resid() %>%
  as_tibble() %>%
  summarise(sd = sd(value)) %>% 
  pull()

p5 <- glm_early %>% 
  resid() %>%
  as_tibble() %>%
  #rstatix::get_summary_stats()
  ggplot(aes(x = value)) +
  
  stat_dist_halfeye(aes(dist = dist_normal(mean_resid_early_glm,
                                           sd_resid_early_glm)),
                    orientation = "horizontal") +
    stat_dotsinterval(aes(x = value),
                    orientation = "horizontal",
                    fill = "firebrick", scale = 1) +
    geom_vline(xintercept = mean_resid_early_glm,
               colour = "blue", linetype = "dashed") +
    labs(title = "through link function",
       x = NULL,
       y = "probability")
```

```{r}
#| echo: false
#| label: fig-beak_class
#| fig-cap: "Classification in beak shape"
p3
```

The data in @fig-beak_class show the classification of beak shape for a collection of finches. They are either classed as `blunt` or `pointed`. Various (continuous) measurements were taken from each bird, with the beak depth shown here.

We'll look into this example in more detail later. For now it's important to note that the response variable (`class`) is not continuous. In this case, it's a binary response (`blunt` or `pointed`). As a result, the assumptions for a regular linear model go out of the window If we were foolish enough to fit a linear model to these data, then the residuals would look rather non-normal (@fig-beak_residuals, A).

With generalised linear models we can actually still _model_ these data as a linear relationship between the predictor (beak length) and response variable (class). But we do this through a **link function** that is able to map this linear predictor to the non-linear relationship in the data.

When we do this and then look at the residuals, we end up with residuals that are much more normally distributed (@fig-beak_residuals, B).

```{r}
#| echo: false
#| label: fig-beak_residuals
#| fig-cap: Beak class model residuals
(p4 + p5) +
  plot_annotation(tag_levels = "A")
```

## Linear predictors

## Link functions

Let's look some data that come from an analysis of gene flow across two finch species.

Two species, _Geospiza fortis_ and _G. scandens_. There are measurements that are split by a uniquely timed event: an particularly strong El Nino event in 1983 changed the vegetation and food supply of the finches, allowing F1 hybrids to survive. These measurements are classed as `early` (pre-1983) and `late` (1983 onwards).

```{r}
#| echo: false
#| message: false
# https://www.nature.com/articles/s41559-020-1183-9#MOESM2
finches_2020 <- read_csv("data/41559_2020_1183_MOESM2_ESM.csv")
```

```{r}
#| echo: false
#| message: false
library(janitor)

finches_2020 <- finches_2020 %>% 
  clean_names() %>% 
  mutate(timepoint = (str_detect(group, "Late")),
         timepoint = if_else(timepoint == FALSE, "early", "late"),
         timepoint = factor(timepoint)) %>% 
  rename(class = group)
  
```

Visualising the different groups:

```{r}
#| echo: false
#| message: false
#| label: fig-beak_classification
#| fig-cap: "Beak classification pre- and post El Nino"
finches_2020 %>% 
ggplot(aes(x = blength, y = class,
           colour = species)) +
  geom_point() +
  facet_wrap(vars(timepoint)) +
  labs(x = "beak length (mm)",
       y = "class")
```

We can see that in the early time point (pre-1983) both species had relatively clear beak shapes. Generally, _G. fortis_ had blunt beaks, whereas _G. scandens_ had pointed beaks.

Let's say we were in a situation where we only had the beak length measurements. Could we make some predictions about the species? Let's first focus on just the early time points.

```{r}
#| echo: false
#| message: false
#| label: fig-beak_classification_nospecies
#| fig-cap: "Beak classification without species information"
# filter for early time points
early_finches <- finches_2020 %>% 
  filter(timepoint == "early") %>% 
  mutate(pointed_beak = if_else(str_detect(class, "blunt"), 0, 1))

ggplot(early_finches, aes(x = blength, y = pointed_beak)) +
  geom_point() +
  labs(x = "beak length (mm)",
       y = "pointed beak")
```

We could try to model this with the knowledge we've got so far and perform a linear regression analysis.

```{r}
ggplot(early_finches, aes(x = blength, y = pointed_beak)) +
  geom_point() +
  geom_smooth(method = "lm", se = FALSE)
```

```{r}
lm_early <- lm(pointed_beak ~ blength,
               data = early_finches)

anova(lm_early)

lm_early %>% 
  resid_panel(plots = c("resid", "qq", "ls", "cookd"),
              smoother = TRUE)

lm_early %>% 
  augment() %>% 
  ggplot(aes(x = .resid)) +
  geom_histogram()
```

Assumptions are definitely violated. Surprisingly, the Q-Q plot and histogram of the residuals doesn't look too bad.

But we can't describe these data with some kind of linear relationship, of course.

```{r}
glm_early <- glm(pointed_beak ~ blength,
                 family = binomial(link = "logit"),
                 data = early_finches)

summary(glm_early)
```

Let's plot the fitted model values:

```{r}
glm_early %>% 
  augment() %>% 
  ggplot(aes(x = blength, y = .fitted)) +
  geom_point(colour = "blue")
```

Main points:

* `blength` is a significant predictor of `pointed_beak`
* the fitted model values are still linear!

The fitted model values are linear because the non-linear relationship between beak length and beak type is linearised by the model. It does so using a **link function**.

In this case the default link function for the binomial family of models is the **logit** function.

So the values we're seeing are on a logit scale. If we wanted to visualise the actual _probabilities_, we could do that as follows (also displaying the model predictions as a dashed line for clarity):

```{r}
glm_early %>% 
  augment(type.predict = "response") %>% 
  ggplot() +
  geom_point(aes(x = blength, y = pointed_beak)) +
  geom_line(aes(x = blength, y = .fitted),
            linetype = "dashed",
            colour = "blue") +
  geom_point(aes(x = blength, y = .fitted),
             colour = "blue", alpha = 0.4) +
  labs(title = "Logistic model predictions for pointed beaks",
       x = "beak length (mm)",
       y = "Probability")
```

From this we can see that the probability of having a pointed beak (which is considered a "success") is approaching 1 as the beak length gets longer.

```{r}
library(modelr)

blength <- data.frame(blength = c(8.2, 9.4, 11.6, 12.8, 13.9, 15.7))

add_predictions(blength, glm_early,
                type = "response")
```

